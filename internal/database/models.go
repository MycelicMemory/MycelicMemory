package database

import (
	"encoding/json"
	"time"
)

// Memory represents a stored memory
// VERIFIED: Matches memories table schema from Local Memory v1.2.0
type Memory struct {
	ID           string    `json:"id"`
	Content      string    `json:"content"`
	Source       string    `json:"source,omitempty"`
	Importance   int       `json:"importance"`
	Tags         []string  `json:"tags,omitempty"`
	SessionID    string    `json:"session_id,omitempty"`
	Domain       string    `json:"domain,omitempty"`
	Embedding    []byte    `json:"embedding,omitempty"`
	CreatedAt    time.Time `json:"created_at"`
	UpdatedAt    time.Time `json:"updated_at"`
	AgentType    string    `json:"agent_type"`
	AgentContext string    `json:"agent_context,omitempty"`
	AccessScope  string    `json:"access_scope"`
	Slug         string    `json:"slug,omitempty"`
	// Hierarchical chunking fields (Phase 1 benchmark improvement)
	ParentMemoryID string `json:"parent_memory_id,omitempty"` // ID of parent memory (null for root)
	ChunkLevel     int    `json:"chunk_level"`                // 0=full/root, 1=paragraph, 2=atomic
	ChunkIndex     int    `json:"chunk_index"`                // Position within parent's chunks
}

// IsChunk returns true if this memory is a chunk (not a root memory)
func (m *Memory) IsChunk() bool {
	return m.ParentMemoryID != ""
}

// IsRoot returns true if this memory is a root memory (not a chunk)
func (m *Memory) IsRoot() bool {
	return m.ParentMemoryID == ""
}

// TagsJSON returns tags as JSON string for database storage
func (m *Memory) TagsJSON() string {
	if len(m.Tags) == 0 {
		return "[]"
	}
	data, _ := json.Marshal(m.Tags)
	return string(data)
}

// ParseTags parses a JSON string into tags slice
func ParseTags(s string) []string {
	if s == "" || s == "[]" {
		return nil
	}
	var tags []string
	json.Unmarshal([]byte(s), &tags)
	return tags
}

// Relationship represents a connection between two memories
// VERIFIED: Matches memory_relationships table schema
type Relationship struct {
	ID               string    `json:"id"`
	SourceMemoryID   string    `json:"source_memory_id"`
	TargetMemoryID   string    `json:"target_memory_id"`
	RelationshipType string    `json:"relationship_type"` // One of 7 verified types
	Strength         float64   `json:"strength"`          // 0.0 to 1.0
	Context          string    `json:"context,omitempty"`
	AutoGenerated    bool      `json:"auto_generated"`
	CreatedAt        time.Time `json:"created_at"`
}

// Category represents a memory category
// VERIFIED: Matches categories table schema
type Category struct {
	ID                  string    `json:"id"`
	Name                string    `json:"name"`
	Description         string    `json:"description"`
	ParentCategoryID    string    `json:"parent_category_id,omitempty"`
	ConfidenceThreshold float64   `json:"confidence_threshold"`
	AutoGenerated       bool      `json:"auto_generated"`
	CreatedAt           time.Time `json:"created_at"`
}

// MemoryCategorization represents the M2M junction between memory and category
// VERIFIED: Matches memory_categorizations table schema
type MemoryCategorization struct {
	MemoryID   string    `json:"memory_id"`
	CategoryID string    `json:"category_id"`
	Confidence float64   `json:"confidence"` // 0.0 to 1.0
	Reasoning  string    `json:"reasoning,omitempty"`
	CreatedAt  time.Time `json:"created_at"`
}

// Domain represents a knowledge domain
// VERIFIED: Matches domains table schema
type Domain struct {
	ID          string    `json:"id"`
	Name        string    `json:"name"`
	Description string    `json:"description,omitempty"`
	CreatedAt   time.Time `json:"created_at"`
	UpdatedAt   time.Time `json:"updated_at"`
}

// VectorMetadata represents embedding metadata
// VERIFIED: Matches vector_metadata table schema
type VectorMetadata struct {
	MemoryID           string    `json:"memory_id"`
	VectorIndex        int       `json:"vector_index"`
	EmbeddingModel     string    `json:"embedding_model"`
	EmbeddingDimension int       `json:"embedding_dimension"` // 768 for nomic-embed-text
	LastUpdated        time.Time `json:"last_updated"`
}

// AgentSession represents a session
// VERIFIED: Matches agent_sessions table schema
type AgentSession struct {
	SessionID    string    `json:"session_id"`
	AgentType    string    `json:"agent_type"` // One of 4 verified types
	AgentContext string    `json:"agent_context,omitempty"`
	CreatedAt    time.Time `json:"created_at"`
	LastAccessed time.Time `json:"last_accessed"`
	IsActive     bool      `json:"is_active"`
	Metadata     string    `json:"metadata"` // JSON string
}

// PerformanceMetric represents an operation timing record
// VERIFIED: Matches performance_metrics table schema
type PerformanceMetric struct {
	ID              int       `json:"id"`
	OperationType   string    `json:"operation_type"`
	ExecutionTimeMs int       `json:"execution_time_ms"`
	MemoryCount     int       `json:"memory_count,omitempty"`
	Timestamp       time.Time `json:"timestamp"`
}

// MigrationLog represents a database migration record
// VERIFIED: Matches migration_log table schema
type MigrationLog struct {
	ID                    string    `json:"id"`
	MigrationType         string    `json:"migration_type"`
	SourceDBPath          string    `json:"source_db_path,omitempty"`
	OriginalSessionID     string    `json:"original_session_id,omitempty"`
	NewSessionID          string    `json:"new_session_id,omitempty"`
	MemoriesMigrated      int       `json:"memories_migrated"`
	RelationshipsMigrated int       `json:"relationships_migrated"`
	CategoriesMigrated    int       `json:"categories_migrated"`
	MigrationTimestamp    time.Time `json:"migration_timestamp"`
	Checksum              string    `json:"checksum,omitempty"`
	Success               bool      `json:"success"`
	ErrorMessage          string    `json:"error_message,omitempty"`
}

// SearchResult represents a memory search result with relevance
type SearchResult struct {
	Memory    *Memory `json:"memory"`
	Relevance float64 `json:"relevance"` // 0.0 to 1.0 (verified: 1.00 = perfect match)
}

// GraphNode represents a node in the relationship graph
type GraphNode struct {
	ID         string `json:"id"`
	Content    string `json:"content"`
	Importance int    `json:"importance"`
	Distance   int    `json:"distance"` // Distance from source node
}

// GraphEdge represents an edge in the relationship graph
type GraphEdge struct {
	SourceID string  `json:"source_id"`
	TargetID string  `json:"target_id"`
	Type     string  `json:"type"`
	Strength float64 `json:"strength"`
}

// Graph represents a memory relationship graph
// VERIFIED: Output format matches local-memory map_graph command
type Graph struct {
	Nodes []GraphNode `json:"nodes"`
	Edges []GraphEdge `json:"edges"`
}

// OptimizedGraphResult contains the full graph data in a single query result
// Used by GetGraphOptimized to eliminate N+1 query patterns
type OptimizedGraphResult struct {
	Nodes         []*Memory       `json:"nodes"`
	Edges         []*Relationship `json:"edges"`
	NodeDistances map[string]int  `json:"node_distances"` // memoryID -> distance from root
	TotalNodes    int             `json:"total_nodes"`
	TotalEdges    int             `json:"total_edges"`
}

// MemoryFilters represents filters for listing memories
type MemoryFilters struct {
	SessionID   string
	Domain      string
	Tags        []string
	MinImportance int
	MaxImportance int
	StartDate   *time.Time
	EndDate     *time.Time
	Limit       int
	Offset      int
}

// SearchFilters represents filters for searching memories
type SearchFilters struct {
	Query       string
	SessionID   string
	Domain      string
	Tags        []string
	UseAI       bool // Use semantic search vs FTS5
	Limit       int
	MinRelevance float64
}

// RelationshipFilters represents filters for finding relationships
type RelationshipFilters struct {
	Type        string
	MinStrength float64
	Limit       int
}


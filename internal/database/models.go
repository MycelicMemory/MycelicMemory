package database

import (
	"encoding/json"
	"time"
)

// Memory represents a stored memory
// VERIFIED: Matches memories table schema from Local Memory v1.2.0
type Memory struct {
	ID           string    `json:"id"`
	Content      string    `json:"content"`
	Source       string    `json:"source,omitempty"`
	Importance   int       `json:"importance"`
	Tags         []string  `json:"tags,omitempty"`
	SessionID    string    `json:"session_id,omitempty"`
	Domain       string    `json:"domain,omitempty"`
	Embedding    []byte    `json:"embedding,omitempty"`
	CreatedAt    time.Time `json:"created_at"`
	UpdatedAt    time.Time `json:"updated_at"`
	AgentType    string    `json:"agent_type"`
	AgentContext string    `json:"agent_context,omitempty"`
	AccessScope  string    `json:"access_scope"`
	Slug         string    `json:"slug,omitempty"`
	// Hierarchical chunking fields (Phase 1 benchmark improvement)
	ParentMemoryID string `json:"parent_memory_id,omitempty"` // ID of parent memory (null for root)
	ChunkLevel     int    `json:"chunk_level"`                // 0=full/root, 1=paragraph, 2=atomic
	ChunkIndex     int    `json:"chunk_index"`                // Position within parent's chunks
}

// IsChunk returns true if this memory is a chunk (not a root memory)
func (m *Memory) IsChunk() bool {
	return m.ParentMemoryID != ""
}

// IsRoot returns true if this memory is a root memory (not a chunk)
func (m *Memory) IsRoot() bool {
	return m.ParentMemoryID == ""
}

// TagsJSON returns tags as JSON string for database storage
func (m *Memory) TagsJSON() string {
	if len(m.Tags) == 0 {
		return "[]"
	}
	data, _ := json.Marshal(m.Tags)
	return string(data)
}

// ParseTags parses a JSON string into tags slice
func ParseTags(s string) []string {
	if s == "" || s == "[]" {
		return nil
	}
	var tags []string
	json.Unmarshal([]byte(s), &tags)
	return tags
}

// Relationship represents a connection between two memories
// VERIFIED: Matches memory_relationships table schema
type Relationship struct {
	ID               string    `json:"id"`
	SourceMemoryID   string    `json:"source_memory_id"`
	TargetMemoryID   string    `json:"target_memory_id"`
	RelationshipType string    `json:"relationship_type"` // One of 7 verified types
	Strength         float64   `json:"strength"`          // 0.0 to 1.0
	Context          string    `json:"context,omitempty"`
	AutoGenerated    bool      `json:"auto_generated"`
	CreatedAt        time.Time `json:"created_at"`
}

// Category represents a memory category
// VERIFIED: Matches categories table schema
type Category struct {
	ID                  string    `json:"id"`
	Name                string    `json:"name"`
	Description         string    `json:"description"`
	ParentCategoryID    string    `json:"parent_category_id,omitempty"`
	ConfidenceThreshold float64   `json:"confidence_threshold"`
	AutoGenerated       bool      `json:"auto_generated"`
	CreatedAt           time.Time `json:"created_at"`
}

// MemoryCategorization represents the M2M junction between memory and category
// VERIFIED: Matches memory_categorizations table schema
type MemoryCategorization struct {
	MemoryID   string    `json:"memory_id"`
	CategoryID string    `json:"category_id"`
	Confidence float64   `json:"confidence"` // 0.0 to 1.0
	Reasoning  string    `json:"reasoning,omitempty"`
	CreatedAt  time.Time `json:"created_at"`
}

// Domain represents a knowledge domain
// VERIFIED: Matches domains table schema
type Domain struct {
	ID          string    `json:"id"`
	Name        string    `json:"name"`
	Description string    `json:"description,omitempty"`
	CreatedAt   time.Time `json:"created_at"`
	UpdatedAt   time.Time `json:"updated_at"`
}

// VectorMetadata represents embedding metadata
// VERIFIED: Matches vector_metadata table schema
type VectorMetadata struct {
	MemoryID           string    `json:"memory_id"`
	VectorIndex        int       `json:"vector_index"`
	EmbeddingModel     string    `json:"embedding_model"`
	EmbeddingDimension int       `json:"embedding_dimension"` // 768 for nomic-embed-text
	LastUpdated        time.Time `json:"last_updated"`
}

// AgentSession represents a session
// VERIFIED: Matches agent_sessions table schema
type AgentSession struct {
	SessionID    string    `json:"session_id"`
	AgentType    string    `json:"agent_type"` // One of 4 verified types
	AgentContext string    `json:"agent_context,omitempty"`
	CreatedAt    time.Time `json:"created_at"`
	LastAccessed time.Time `json:"last_accessed"`
	IsActive     bool      `json:"is_active"`
	Metadata     string    `json:"metadata"` // JSON string
}

// PerformanceMetric represents an operation timing record
// VERIFIED: Matches performance_metrics table schema
type PerformanceMetric struct {
	ID              int       `json:"id"`
	OperationType   string    `json:"operation_type"`
	ExecutionTimeMs int       `json:"execution_time_ms"`
	MemoryCount     int       `json:"memory_count,omitempty"`
	Timestamp       time.Time `json:"timestamp"`
}

// MigrationLog represents a database migration record
// VERIFIED: Matches migration_log table schema
type MigrationLog struct {
	ID                    string    `json:"id"`
	MigrationType         string    `json:"migration_type"`
	SourceDBPath          string    `json:"source_db_path,omitempty"`
	OriginalSessionID     string    `json:"original_session_id,omitempty"`
	NewSessionID          string    `json:"new_session_id,omitempty"`
	MemoriesMigrated      int       `json:"memories_migrated"`
	RelationshipsMigrated int       `json:"relationships_migrated"`
	CategoriesMigrated    int       `json:"categories_migrated"`
	MigrationTimestamp    time.Time `json:"migration_timestamp"`
	Checksum              string    `json:"checksum,omitempty"`
	Success               bool      `json:"success"`
	ErrorMessage          string    `json:"error_message,omitempty"`
}

// SearchResult represents a memory search result with relevance
type SearchResult struct {
	Memory    *Memory `json:"memory"`
	Relevance float64 `json:"relevance"` // 0.0 to 1.0 (verified: 1.00 = perfect match)
}

// GraphNode represents a node in the relationship graph
type GraphNode struct {
	ID         string `json:"id"`
	Content    string `json:"content"`
	Importance int    `json:"importance"`
	Distance   int    `json:"distance"` // Distance from source node
}

// GraphEdge represents an edge in the relationship graph
type GraphEdge struct {
	SourceID string  `json:"source_id"`
	TargetID string  `json:"target_id"`
	Type     string  `json:"type"`
	Strength float64 `json:"strength"`
}

// Graph represents a memory relationship graph
// VERIFIED: Output format matches local-memory map_graph command
type Graph struct {
	Nodes []GraphNode `json:"nodes"`
	Edges []GraphEdge `json:"edges"`
}

// OptimizedGraphResult contains the full graph data in a single query result
// Used by GetGraphOptimized to eliminate N+1 query patterns
type OptimizedGraphResult struct {
	Nodes         []*Memory       `json:"nodes"`
	Edges         []*Relationship `json:"edges"`
	NodeDistances map[string]int  `json:"node_distances"` // memoryID -> distance from root
	TotalNodes    int             `json:"total_nodes"`
	TotalEdges    int             `json:"total_edges"`
}

// MemoryFilters represents filters for listing memories
type MemoryFilters struct {
	SessionID   string
	Domain      string
	Tags        []string
	MinImportance int
	MaxImportance int
	StartDate   *time.Time
	EndDate     *time.Time
	Limit       int
	Offset      int
}

// SearchFilters represents filters for searching memories
type SearchFilters struct {
	Query       string
	SessionID   string
	Domain      string
	Tags        []string
	UseAI       bool // Use semantic search vs FTS5
	Limit       int
	MinRelevance float64
}

// RelationshipFilters represents filters for finding relationships
type RelationshipFilters struct {
	Type        string
	MinStrength float64
	Limit       int
}

// =============================================================================
// BENCHMARK MODELS
// =============================================================================

// BenchmarkRun represents a single benchmark execution
type BenchmarkRun struct {
	ID            string     `json:"id"`
	StartedAt     time.Time  `json:"started_at"`
	CompletedAt   *time.Time `json:"completed_at,omitempty"`
	Status        string     `json:"status"` // pending, running, completed, failed, cancelled

	// Git context
	GitCommitHash string `json:"git_commit_hash"`
	GitBranch     string `json:"git_branch,omitempty"`
	GitDirty      bool   `json:"git_dirty"`

	// Configuration
	ConfigSnapshot string `json:"config_snapshot"` // JSON
	BenchmarkType  string `json:"benchmark_type"`  // locomo, etc.

	// Results
	OverallScore   *float64 `json:"overall_score,omitempty"`
	OverallF1      *float64 `json:"overall_f1,omitempty"`
	OverallBleu1   *float64 `json:"overall_bleu1,omitempty"`
	TotalQuestions *int     `json:"total_questions,omitempty"`
	TotalCorrect   *int     `json:"total_correct,omitempty"`

	// Timing
	DurationSeconds *float64 `json:"duration_seconds,omitempty"`

	// Error
	ErrorMessage string `json:"error_message,omitempty"`

	// Comparison
	BaselineRunID           string   `json:"baseline_run_id,omitempty"`
	ImprovementFromBaseline *float64 `json:"improvement_from_baseline,omitempty"`
	IsBestRun               bool     `json:"is_best_run"`

	// Autonomous loop
	AutonomousLoopID  string `json:"autonomous_loop_id,omitempty"`
	IterationNumber   int    `json:"iteration_number"`
	ChangeDescription string `json:"change_description,omitempty"`

	// Metadata
	CreatedBy string `json:"created_by"` // manual, mcp, autonomous
	Notes     string `json:"notes,omitempty"`
}

// BenchmarkCategoryResult represents per-category results
type BenchmarkCategoryResult struct {
	ID       string `json:"id"`
	RunID    string `json:"run_id"`
	Category string `json:"category"` // single_hop, multi_hop, temporal, open_domain, adversarial

	// Scores
	LLMJudgeAccuracy *float64 `json:"llm_judge_accuracy,omitempty"`
	F1Score          *float64 `json:"f1_score,omitempty"`
	Bleu1Score       *float64 `json:"bleu1_score,omitempty"`

	// Counts
	TotalQuestions *int `json:"total_questions,omitempty"`
	CorrectCount   *int `json:"correct_count,omitempty"`

	// Comparison
	PreviousBestAccuracy *float64 `json:"previous_best_accuracy,omitempty"`
	Improvement          *float64 `json:"improvement,omitempty"`
}

// BenchmarkQuestionResult represents individual question results
type BenchmarkQuestionResult struct {
	ID    string `json:"id"`
	RunID string `json:"run_id"`

	// Question identification
	QuestionID   string `json:"question_id"`
	Category     string `json:"category"`
	QuestionText string `json:"question_text"`

	// Answers
	GoldAnswer      string `json:"gold_answer"`
	GeneratedAnswer string `json:"generated_answer,omitempty"`

	// Scores
	LLMJudgeLabel *int     `json:"llm_judge_label,omitempty"` // 0 or 1
	F1Score       *float64 `json:"f1_score,omitempty"`
	Bleu1Score    *float64 `json:"bleu1_score,omitempty"`

	// Context metrics
	ContextLength    *int `json:"context_length,omitempty"`
	MemoriesUsed     *int `json:"memories_used,omitempty"`
	RetrievalTimeMs  *int `json:"retrieval_time_ms,omitempty"`
	GenerationTimeMs *int `json:"generation_time_ms,omitempty"`

	// Comparison
	ChangedFromPrevious *bool `json:"changed_from_previous,omitempty"`
	PreviousWasCorrect  *bool `json:"previous_was_correct,omitempty"`
}

// AutonomousLoop represents an autonomous improvement session
type AutonomousLoop struct {
	ID          string     `json:"id"`
	StartedAt   time.Time  `json:"started_at"`
	CompletedAt *time.Time `json:"completed_at,omitempty"`
	Status      string     `json:"status"` // running, completed, stopped, failed

	// Configuration
	MaxIterations           int     `json:"max_iterations"`
	MinImprovementThreshold float64 `json:"min_improvement_threshold"`
	ConvergenceThreshold    float64 `json:"convergence_threshold"`

	// Results
	TotalIterations int      `json:"total_iterations"`
	BaselineScore   *float64 `json:"baseline_score,omitempty"`
	FinalScore      *float64 `json:"final_score,omitempty"`
	BestScore       *float64 `json:"best_score,omitempty"`
	BestRunID       string   `json:"best_run_id,omitempty"`

	// Stop reason
	StopReason string `json:"stop_reason,omitempty"`

	// Change tracking (JSON arrays)
	ChangesAttempted string `json:"changes_attempted,omitempty"`
	ChangesAccepted  string `json:"changes_accepted,omitempty"`
	ChangesRejected  string `json:"changes_rejected,omitempty"`
}

// BenchmarkRunFilters for querying benchmark runs
type BenchmarkRunFilters struct {
	Status        string
	BenchmarkType string
	GitCommit     string
	LoopID        string
	Since         *time.Time
	Until         *time.Time
	Limit         int
	Offset        int
}

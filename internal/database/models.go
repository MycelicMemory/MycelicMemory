package database

import (
	"encoding/json"
	"time"
)

// Memory represents a stored memory
// VERIFIED: Matches memories table schema from Local Memory v1.2.0
type Memory struct {
	ID           string    `json:"id"`
	Content      string    `json:"content"`
	Source       string    `json:"source,omitempty"`
	Importance   int       `json:"importance"`
	Tags         []string  `json:"tags,omitempty"`
	SessionID    string    `json:"session_id,omitempty"`
	Domain       string    `json:"domain,omitempty"`
	Embedding    []byte    `json:"embedding,omitempty"`
	CreatedAt    time.Time `json:"created_at"`
	UpdatedAt    time.Time `json:"updated_at"`
	AgentType    string    `json:"agent_type"`
	AgentContext string    `json:"agent_context,omitempty"`
	AccessScope  string    `json:"access_scope"`
	Slug         string    `json:"slug,omitempty"`
	// Hierarchical chunking fields (Phase 1 benchmark improvement)
	ParentMemoryID string `json:"parent_memory_id,omitempty"` // ID of parent memory (null for root)
	ChunkLevel     int    `json:"chunk_level"`                // 0=full/root, 1=paragraph, 2=atomic
	ChunkIndex     int    `json:"chunk_index"`                // Position within parent's chunks
	// Multi-source ingestion fields (Schema v3)
	SourceID   string `json:"source_id,omitempty"`   // Reference to data_sources.id
	ExternalID string `json:"external_id,omitempty"` // Unique ID in source system (for deduplication)
}

// IsChunk returns true if this memory is a chunk (not a root memory)
func (m *Memory) IsChunk() bool {
	return m.ParentMemoryID != ""
}

// IsRoot returns true if this memory is a root memory (not a chunk)
func (m *Memory) IsRoot() bool {
	return m.ParentMemoryID == ""
}

// TagsJSON returns tags as JSON string for database storage
func (m *Memory) TagsJSON() string {
	if len(m.Tags) == 0 {
		return "[]"
	}
	data, _ := json.Marshal(m.Tags)
	return string(data)
}

// ParseTags parses a JSON string into tags slice
func ParseTags(s string) []string {
	if s == "" || s == "[]" {
		return nil
	}
	var tags []string
	_ = json.Unmarshal([]byte(s), &tags)
	return tags
}

// Relationship represents a connection between two memories
// VERIFIED: Matches memory_relationships table schema
type Relationship struct {
	ID               string    `json:"id"`
	SourceMemoryID   string    `json:"source_memory_id"`
	TargetMemoryID   string    `json:"target_memory_id"`
	RelationshipType string    `json:"relationship_type"` // One of 7 verified types
	Strength         float64   `json:"strength"`          // 0.0 to 1.0
	Context          string    `json:"context,omitempty"`
	AutoGenerated    bool      `json:"auto_generated"`
	CreatedAt        time.Time `json:"created_at"`
}

// Category represents a memory category
// VERIFIED: Matches categories table schema
type Category struct {
	ID                  string    `json:"id"`
	Name                string    `json:"name"`
	Description         string    `json:"description"`
	ParentCategoryID    string    `json:"parent_category_id,omitempty"`
	ConfidenceThreshold float64   `json:"confidence_threshold"`
	AutoGenerated       bool      `json:"auto_generated"`
	CreatedAt           time.Time `json:"created_at"`
}

// MemoryCategorization represents the M2M junction between memory and category
// VERIFIED: Matches memory_categorizations table schema
type MemoryCategorization struct {
	MemoryID   string    `json:"memory_id"`
	CategoryID string    `json:"category_id"`
	Confidence float64   `json:"confidence"` // 0.0 to 1.0
	Reasoning  string    `json:"reasoning,omitempty"`
	CreatedAt  time.Time `json:"created_at"`
}

// Domain represents a knowledge domain
// VERIFIED: Matches domains table schema
type Domain struct {
	ID          string    `json:"id"`
	Name        string    `json:"name"`
	Description string    `json:"description,omitempty"`
	CreatedAt   time.Time `json:"created_at"`
	UpdatedAt   time.Time `json:"updated_at"`
}

// VectorMetadata represents embedding metadata
// VERIFIED: Matches vector_metadata table schema
type VectorMetadata struct {
	MemoryID           string    `json:"memory_id"`
	VectorIndex        int       `json:"vector_index"`
	EmbeddingModel     string    `json:"embedding_model"`
	EmbeddingDimension int       `json:"embedding_dimension"` // 768 for nomic-embed-text
	LastUpdated        time.Time `json:"last_updated"`
}

// AgentSession represents a session
// VERIFIED: Matches agent_sessions table schema
type AgentSession struct {
	SessionID    string    `json:"session_id"`
	AgentType    string    `json:"agent_type"` // One of 4 verified types
	AgentContext string    `json:"agent_context,omitempty"`
	CreatedAt    time.Time `json:"created_at"`
	LastAccessed time.Time `json:"last_accessed"`
	IsActive     bool      `json:"is_active"`
	Metadata     string    `json:"metadata"` // JSON string
}

// PerformanceMetric represents an operation timing record
// VERIFIED: Matches performance_metrics table schema
type PerformanceMetric struct {
	ID              int       `json:"id"`
	OperationType   string    `json:"operation_type"`
	ExecutionTimeMs int       `json:"execution_time_ms"`
	MemoryCount     int       `json:"memory_count,omitempty"`
	Timestamp       time.Time `json:"timestamp"`
}

// MigrationLog represents a database migration record
// VERIFIED: Matches migration_log table schema
type MigrationLog struct {
	ID                    string    `json:"id"`
	MigrationType         string    `json:"migration_type"`
	SourceDBPath          string    `json:"source_db_path,omitempty"`
	OriginalSessionID     string    `json:"original_session_id,omitempty"`
	NewSessionID          string    `json:"new_session_id,omitempty"`
	MemoriesMigrated      int       `json:"memories_migrated"`
	RelationshipsMigrated int       `json:"relationships_migrated"`
	CategoriesMigrated    int       `json:"categories_migrated"`
	MigrationTimestamp    time.Time `json:"migration_timestamp"`
	Checksum              string    `json:"checksum,omitempty"`
	Success               bool      `json:"success"`
	ErrorMessage          string    `json:"error_message,omitempty"`
}

// SearchResult represents a memory search result with relevance
type SearchResult struct {
	Memory    *Memory `json:"memory"`
	Relevance float64 `json:"relevance"` // 0.0 to 1.0 (verified: 1.00 = perfect match)
}

// GraphNode represents a node in the relationship graph
type GraphNode struct {
	ID         string `json:"id"`
	Content    string `json:"content"`
	Importance int    `json:"importance"`
	Distance   int    `json:"distance"` // Distance from source node
}

// GraphEdge represents an edge in the relationship graph
type GraphEdge struct {
	SourceID string  `json:"source_id"`
	TargetID string  `json:"target_id"`
	Type     string  `json:"type"`
	Strength float64 `json:"strength"`
}

// Graph represents a memory relationship graph
// VERIFIED: Output format matches local-memory map_graph command
type Graph struct {
	Nodes []GraphNode `json:"nodes"`
	Edges []GraphEdge `json:"edges"`
}

// OptimizedGraphResult contains the full graph data in a single query result
// Used by GetGraphOptimized to eliminate N+1 query patterns
type OptimizedGraphResult struct {
	Nodes         []*Memory       `json:"nodes"`
	Edges         []*Relationship `json:"edges"`
	NodeDistances map[string]int  `json:"node_distances"` // memoryID -> distance from root
	TotalNodes    int             `json:"total_nodes"`
	TotalEdges    int             `json:"total_edges"`
}

// MemoryFilters represents filters for listing memories
type MemoryFilters struct {
	SessionID   string
	Domain      string
	Tags        []string
	MinImportance int
	MaxImportance int
	StartDate   *time.Time
	EndDate     *time.Time
	Limit       int
	Offset      int
}

// SearchFilters represents filters for searching memories
type SearchFilters struct {
	Query        string
	SessionID    string
	Domain       string
	Tags         []string
	UseAI        bool // Use semantic search vs FTS5
	Limit        int
	MinRelevance float64
	SourceID     string // Filter by data source
}

// RelationshipFilters represents filters for finding relationships
type RelationshipFilters struct {
	Type        string
	MinStrength float64
	Limit       int
}

// =============================================================================
// DATA SOURCE MODELS (Schema v3)
// =============================================================================

// DataSource represents a configured data source for memory ingestion
type DataSource struct {
	ID               string     `json:"id"`
	SourceType       string     `json:"source_type"`       // 'slack' | 'claude-stream' | 'email' | etc.
	Name             string     `json:"name"`              // User-friendly display name
	Config           string     `json:"config"`            // JSON configuration (source-specific)
	Status           string     `json:"status"`            // 'active' | 'paused' | 'error'
	LastSyncAt       *time.Time `json:"last_sync_at"`      // Last successful sync timestamp
	LastSyncPosition string     `json:"last_sync_position"` // Cursor/checkpoint for incremental sync
	ErrorMessage     string     `json:"error_message,omitempty"`
	CreatedAt        time.Time  `json:"created_at"`
	UpdatedAt        time.Time  `json:"updated_at"`
}

// DataSourceSyncHistory represents a sync operation record
type DataSourceSyncHistory struct {
	ID               string     `json:"id"`
	SourceID         string     `json:"source_id"`
	StartedAt        time.Time  `json:"started_at"`
	CompletedAt      *time.Time `json:"completed_at,omitempty"`
	ItemsProcessed   int        `json:"items_processed"`
	MemoriesCreated  int        `json:"memories_created"`
	DuplicatesSkipped int       `json:"duplicates_skipped"`
	Status           string     `json:"status"` // 'running' | 'completed' | 'failed'
	Error            string     `json:"error,omitempty"`
}

// DataSourceFilters represents filters for listing data sources
type DataSourceFilters struct {
	SourceType string
	Status     string
	Limit      int
	Offset     int
}

// DataSourceStats contains statistics for a data source
type DataSourceStats struct {
	TotalMemories   int        `json:"total_memories"`
	TotalSyncs      int        `json:"total_syncs"`
	SuccessfulSyncs int        `json:"successful_syncs"`
	FailedSyncs     int        `json:"failed_syncs"`
	LastSyncAt      *time.Time `json:"last_sync_at"`
	LastError       string     `json:"last_error,omitempty"`
}

// IngestItem represents an item to be ingested from a data source
type IngestItem struct {
	ExternalID  string            `json:"external_id"`  // Unique ID in source system
	Content     string            `json:"content"`      // Raw content
	ContentType string            `json:"content_type"` // 'text' | 'code' | 'markdown' | 'html'
	Timestamp   time.Time         `json:"timestamp"`
	Metadata    IngestMetadata    `json:"metadata"`
}

// IngestMetadata contains source-specific metadata for ingested items
type IngestMetadata struct {
	SourceType     string   `json:"source_type"`
	Author         string   `json:"author,omitempty"`
	Channel        string   `json:"channel,omitempty"`  // For Slack
	ThreadID       string   `json:"thread_id,omitempty"`
	FileReferences []string `json:"file_references,omitempty"`
	Importance     int      `json:"importance,omitempty"`
	Tags           []string `json:"tags,omitempty"`
	Domain         string   `json:"domain,omitempty"`
}

// IngestRequest represents a bulk ingestion request
type IngestRequest struct {
	Items      []IngestItem `json:"items"`
	Checkpoint string       `json:"checkpoint,omitempty"` // For resumable sync
}

// IngestResponse represents the result of an ingestion operation
type IngestResponse struct {
	Processed         int    `json:"processed"`
	MemoriesCreated   int    `json:"memories_created"`
	DuplicatesSkipped int    `json:"duplicates_skipped"`
	Checkpoint        string `json:"checkpoint"`
}

// DataSourceUpdate represents optional updates to a data source
type DataSourceUpdate struct {
	Name             *string `json:"name,omitempty"`
	Config           *string `json:"config,omitempty"`
	Status           *string `json:"status,omitempty"`
	LastSyncPosition *string `json:"last_sync_position,omitempty"`
	ErrorMessage     *string `json:"error_message,omitempty"`
}


package api

import (
	"time"

	"github.com/gin-gonic/gin"

	"github.com/MycelicMemory/mycelicmemory/internal/database"
)

// HealthResponse represents health check response
type HealthResponse struct {
	Status    string `json:"status"`
	Session   string `json:"session"`
	Timestamp string `json:"timestamp"`
}

// StatsResponse represents system statistics
type StatsResponse struct {
	TotalMemories     int                 `json:"total_memories"`
	AverageImportance float64             `json:"average_importance"`
	UniqueTags        []string            `json:"unique_tags"`
	MostCommonTags    []TagCount          `json:"most_common_tags"`
	DateRange         DateRangeStats      `json:"date_range"`
	SessionID         string              `json:"session_id"`
}

// TagCount represents a tag and its count
type TagCount struct {
	Tag   string `json:"tag"`
	Count int    `json:"count"`
}

// DateRangeStats represents date range info
type DateRangeStats struct {
	Earliest time.Time `json:"earliest"`
	Latest   time.Time `json:"latest"`
}

// CreateCategoryRequest represents a category creation request
type CreateCategoryRequest struct {
	Name        string `json:"name" binding:"required"`
	Description string `json:"description"`
	ParentID    string `json:"parent_id"`
}

// CategoryResponse represents a category in responses
type CategoryResponse struct {
	ID                  string    `json:"id"`
	Name                string    `json:"name"`
	Description         string    `json:"description"`
	ParentCategoryID    *string   `json:"parent_category_id"`
	ConfidenceThreshold float64   `json:"confidence_threshold"`
	AutoGenerated       bool      `json:"auto_generated"`
	CreatedAt           time.Time `json:"created_at"`
}

// CreateDomainRequest represents a domain creation request
type CreateDomainRequest struct {
	Name        string `json:"name" binding:"required"`
	Description string `json:"description"`
}

// DomainResponse represents a domain in responses
type DomainResponse struct {
	ID          string    `json:"id"`
	Name        string    `json:"name"`
	Description string    `json:"description"`
	CreatedAt   time.Time `json:"created_at"`
	UpdatedAt   time.Time `json:"updated_at"`
}

// DomainStatsResponse represents domain statistics
type DomainStatsResponse struct {
	Domain            string  `json:"domain"`
	MemoryCount       int     `json:"memory_count"`
	AverageImportance float64 `json:"average_importance"`
}

// SessionResponse represents a session in responses
type SessionResponse struct {
	SessionID    string    `json:"session_id"`
	AgentType    string    `json:"agent_type"`
	CreatedAt    time.Time `json:"created_at"`
	LastAccessed time.Time `json:"last_accessed"`
	IsActive     bool      `json:"is_active"`
}

// healthHandler handles GET /api/v1/health
func (s *Server) healthHandler(c *gin.Context) {
	// Get AI service status
	aiStatus := s.aiManager.GetStatus()

	response := struct {
		Status    string `json:"status"`
		Session   string `json:"session"`
		Timestamp string `json:"timestamp"`
		Ollama    bool   `json:"ollama"`
		Qdrant    bool   `json:"qdrant"`
		Database  bool   `json:"database"`
	}{
		Status:    "healthy",
		Session:   s.sessionID,
		Timestamp: time.Now().UTC().Format(time.RFC3339),
		Ollama:    aiStatus.OllamaAvailable,
		Qdrant:    aiStatus.QdrantAvailable,
		Database:  true,
	}

	SuccessResponse(c, "Server is healthy", response)
}

// systemStats handles GET /api/v1/stats
func (s *Server) systemStats(c *gin.Context) {
	// Get all memories for stats calculation
	memories, err := s.db.ListMemories(&database.MemoryFilters{Limit: 10000})
	if err != nil {
		InternalError(c, "Failed to get statistics: "+err.Error())
		return
	}

	// Calculate stats
	totalMemories := len(memories)
	var sumImportance float64
	tagCounts := make(map[string]int)
	var earliest, latest time.Time

	for _, m := range memories {
		sumImportance += float64(m.Importance)

		for _, tag := range m.Tags {
			tagCounts[tag]++
		}

		if earliest.IsZero() || m.CreatedAt.Before(earliest) {
			earliest = m.CreatedAt
		}
		if latest.IsZero() || m.CreatedAt.After(latest) {
			latest = m.CreatedAt
		}
	}

	var avgImportance float64
	if totalMemories > 0 {
		avgImportance = sumImportance / float64(totalMemories)
	}

	// Get unique tags
	uniqueTags := make([]string, 0, len(tagCounts))
	for tag := range tagCounts {
		uniqueTags = append(uniqueTags, tag)
	}

	// Get most common tags (top 10)
	mostCommonTags := []TagCount{}
	// Simple approach: just return empty for now (matches local-memory behavior when there's limited data)

	response := &StatsResponse{
		TotalMemories:     totalMemories,
		AverageImportance: avgImportance,
		UniqueTags:        uniqueTags,
		MostCommonTags:    mostCommonTags,
		DateRange: DateRangeStats{
			Earliest: earliest,
			Latest:   latest,
		},
		SessionID: s.sessionID,
	}

	SuccessResponse(c, "System statistics retrieved successfully", response)
}

// createCategory handles POST /api/v1/categories
func (s *Server) createCategory(c *gin.Context) {
	var req CreateCategoryRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		BadRequestError(c, "Invalid request body: "+err.Error())
		return
	}

	category := &database.Category{
		Name:                req.Name,
		Description:         req.Description,
		ParentCategoryID:    req.ParentID,
		ConfidenceThreshold: 0.7,
		AutoGenerated:       false,
	}

	if err := s.db.CreateCategory(category); err != nil {
		InternalError(c, "Failed to create category: "+err.Error())
		return
	}

	response := toCategoryResponse(category)
	CreatedResponse(c, "Category created successfully", response)
}

// listCategories handles GET /api/v1/categories
func (s *Server) listCategories(c *gin.Context) {
	categories, err := s.db.ListCategories()
	if err != nil {
		InternalError(c, "Failed to list categories: "+err.Error())
		return
	}

	response := make([]*CategoryResponse, len(categories))
	for i, cat := range categories {
		response[i] = toCategoryResponse(cat)
	}

	SuccessResponse(c, "Found "+intToString(len(categories))+" categories", response)
}

// categorizeMemory handles POST /api/v1/memories/:id/categorize
func (s *Server) categorizeMemory(c *gin.Context) {
	memoryID := c.Param("id")

	var req struct {
		CategoryID string  `json:"category_id"`
		Confidence float64 `json:"confidence"`
		Reasoning  string  `json:"reasoning"`
	}
	if err := c.ShouldBindJSON(&req); err != nil {
		BadRequestError(c, "Invalid request body: "+err.Error())
		return
	}

	if req.CategoryID == "" {
		BadRequestError(c, "category_id is required")
		return
	}

	confidence := req.Confidence
	if confidence <= 0 {
		confidence = 0.7
	}

	err := s.db.CategorizeMemory(memoryID, req.CategoryID, confidence, req.Reasoning)
	if err != nil {
		InternalError(c, "Failed to categorize memory: "+err.Error())
		return
	}

	SuccessResponse(c, "Memory categorized successfully", nil)
}

// categoryStats handles GET /api/v1/categories/stats
func (s *Server) categoryStats(c *gin.Context) {
	categories, err := s.db.ListCategories()
	if err != nil {
		InternalError(c, "Failed to get category stats: "+err.Error())
		return
	}

	response := struct {
		TotalCategories int `json:"total_categories"`
	}{
		TotalCategories: len(categories),
	}

	SuccessResponse(c, "Category statistics retrieved", response)
}

// createDomain handles POST /api/v1/domains
func (s *Server) createDomain(c *gin.Context) {
	var req CreateDomainRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		BadRequestError(c, "Invalid request body: "+err.Error())
		return
	}

	domain := &database.Domain{
		Name:        req.Name,
		Description: req.Description,
	}

	if err := s.db.CreateDomain(domain); err != nil {
		InternalError(c, "Failed to create domain: "+err.Error())
		return
	}

	response := toDomainResponse(domain)
	CreatedResponse(c, "Domain created successfully", response)
}

// listDomains handles GET /api/v1/domains
func (s *Server) listDomains(c *gin.Context) {
	domains, err := s.db.ListDomains()
	if err != nil {
		InternalError(c, "Failed to list domains: "+err.Error())
		return
	}

	domainResponses := make([]*DomainResponse, len(domains))
	for i, d := range domains {
		domainResponses[i] = toDomainResponse(d)
	}

	// local-memory wraps domains in a 'domains' key
	response := struct {
		Domains []*DomainResponse `json:"domains"`
	}{
		Domains: domainResponses,
	}

	SuccessResponse(c, "Domains retrieved successfully", response)
}

// domainStats handles GET /api/v1/domains/:domain/stats
func (s *Server) domainStats(c *gin.Context) {
	domainName := c.Param("domain")

	stats, err := s.db.GetDomainStats(domainName)
	if err != nil {
		InternalError(c, "Failed to get domain stats: "+err.Error())
		return
	}

	response := &DomainStatsResponse{
		Domain:            domainName,
		MemoryCount:       stats.MemoryCount,
		AverageImportance: stats.AverageImportance,
	}

	SuccessResponse(c, "Domain statistics retrieved", response)
}

// listSessions handles GET /api/v1/sessions
func (s *Server) listSessions(c *gin.Context) {
	sessions, err := s.db.ListSessions()
	if err != nil {
		InternalError(c, "Failed to list sessions: "+err.Error())
		return
	}

	// local-memory returns just session IDs as strings
	sessionIDs := make([]string, len(sessions))
	for i, sess := range sessions {
		sessionIDs[i] = sess.SessionID
	}

	SuccessResponse(c, "Found "+intToString(len(sessions))+" sessions", sessionIDs)
}

// sessionStats handles GET /api/v1/sessions/stats
func (s *Server) sessionStats(c *gin.Context) {
	sessions, err := s.db.ListSessions()
	if err != nil {
		InternalError(c, "Failed to get session stats: "+err.Error())
		return
	}

	// Get total memory count from all memories
	memories, _ := s.db.ListMemories(&database.MemoryFilters{Limit: 100000})
	totalMemories := len(memories)

	response := struct {
		TotalSessions  int    `json:"total_sessions"`
		TotalMemories  int    `json:"total_memories"`
		CurrentSession string `json:"current_session"`
	}{
		TotalSessions:  len(sessions),
		TotalMemories:  totalMemories,
		CurrentSession: s.sessionID,
	}

	SuccessResponse(c, "Session statistics retrieved", response)
}

// Helper functions
func toCategoryResponse(c *database.Category) *CategoryResponse {
	var parentID *string
	if c.ParentCategoryID != "" {
		parentID = &c.ParentCategoryID
	}

	return &CategoryResponse{
		ID:                  c.ID,
		Name:                c.Name,
		Description:         c.Description,
		ParentCategoryID:    parentID,
		ConfidenceThreshold: c.ConfidenceThreshold,
		AutoGenerated:       c.AutoGenerated,
		CreatedAt:           c.CreatedAt,
	}
}

func toDomainResponse(d *database.Domain) *DomainResponse {
	return &DomainResponse{
		ID:          d.ID,
		Name:        d.Name,
		Description: d.Description,
		CreatedAt:   d.CreatedAt,
		UpdatedAt:   d.UpdatedAt,
	}
}

func intToString(n int) string {
	if n == 0 {
		return "0"
	}

	var digits []byte
	for n > 0 {
		digits = append([]byte{byte('0' + n%10)}, digits...)
		n /= 10
	}
	return string(digits)
}

package relationships

import (
	"fmt"
	"strings"

	"github.com/MycelicMemory/ultrathink/internal/database"
	"github.com/MycelicMemory/ultrathink/pkg/config"
)

// Service provides the business logic for relationship operations
// VERIFIED: Implements all local-memory relationship features
type Service struct {
	db     *database.Database
	config *config.Config
}

// NewService creates a new relationship service
func NewService(db *database.Database, cfg *config.Config) *Service {
	return &Service{
		db:     db,
		config: cfg,
	}
}

// CreateOptions contains options for creating a relationship
type CreateOptions struct {
	SourceMemoryID   string
	TargetMemoryID   string
	RelationshipType string  // One of 7 valid types
	Strength         float64 // 0.0 to 1.0
	Context          string  // Optional explanation
	AutoGenerated    bool    // True if AI-discovered
}

// Create creates a new relationship between two memories
// VERIFIED: Matches local-memory create relationship behavior
func (s *Service) Create(opts *CreateOptions) (*database.Relationship, error) {
	// Validate source and target exist
	source, err := s.db.GetMemory(opts.SourceMemoryID)
	if err != nil {
		return nil, fmt.Errorf("failed to get source memory: %w", err)
	}
	if source == nil {
		return nil, fmt.Errorf("source memory not found: %s", opts.SourceMemoryID)
	}

	target, err := s.db.GetMemory(opts.TargetMemoryID)
	if err != nil {
		return nil, fmt.Errorf("failed to get target memory: %w", err)
	}
	if target == nil {
		return nil, fmt.Errorf("target memory not found: %s", opts.TargetMemoryID)
	}

	// Validate and normalize relationship type
	relType := strings.ToLower(strings.TrimSpace(opts.RelationshipType))
	if !database.IsValidRelationshipType(relType) {
		return nil, fmt.Errorf("invalid relationship type: %s (valid: %s)",
			opts.RelationshipType, strings.Join(database.RelationshipTypes, ", "))
	}

	// Validate strength
	strength := opts.Strength
	if strength < 0.0 {
		strength = 0.5 // Default
	}
	if strength > 1.0 {
		strength = 1.0
	}

	// Create relationship
	rel := &database.Relationship{
		SourceMemoryID:   opts.SourceMemoryID,
		TargetMemoryID:   opts.TargetMemoryID,
		RelationshipType: relType,
		Strength:         strength,
		Context:          opts.Context,
		AutoGenerated:    opts.AutoGenerated,
	}

	if err := s.db.CreateRelationship(rel); err != nil {
		return nil, fmt.Errorf("failed to create relationship: %w", err)
	}

	return rel, nil
}

// FindRelatedOptions contains options for finding related memories
type FindRelatedOptions struct {
	MemoryID    string
	Type        string  // Filter by relationship type
	MinStrength float64 // Filter by minimum strength
	Limit       int
}

// FindRelatedResult represents a related memory with relationship info
type FindRelatedResult struct {
	Memory           *database.Memory `json:"memory"`
	RelationshipType string           `json:"relationship_type"`
	Strength         float64          `json:"strength"`
	Direction        string           `json:"direction"` // "outgoing" or "incoming"
}

// FindRelated finds memories related to a given memory
// VERIFIED: Matches local-memory find_related behavior
func (s *Service) FindRelated(opts *FindRelatedOptions) ([]*FindRelatedResult, error) {
	if opts.MemoryID == "" {
		return nil, fmt.Errorf("memory_id is required")
	}

	// Validate memory exists
	mem, err := s.db.GetMemory(opts.MemoryID)
	if err != nil {
		return nil, fmt.Errorf("failed to get memory: %w", err)
	}
	if mem == nil {
		return nil, fmt.Errorf("memory not found: %s", opts.MemoryID)
	}

	filters := &database.RelationshipFilters{
		Type:        strings.ToLower(opts.Type),
		MinStrength: opts.MinStrength,
		Limit:       opts.Limit,
	}

	if filters.Limit <= 0 {
		filters.Limit = 10
	}

	memories, err := s.db.FindRelated(opts.MemoryID, filters)
	if err != nil {
		return nil, fmt.Errorf("failed to find related: %w", err)
	}

	// TODO: Get full relationship info for each result
	// For now, just return memories
	var results []*FindRelatedResult
	for _, m := range memories {
		results = append(results, &FindRelatedResult{
			Memory:    m,
			Strength:  1.0, // Placeholder
			Direction: "related",
		})
	}

	return results, nil
}

// MapGraphOptions contains options for mapping the relationship graph
type MapGraphOptions struct {
	RootID        string
	Depth         int
	IncludeTypes  []string // Filter by relationship types
	MinStrength   float64
	IncludeNodes  bool // Include full node data
}

// GraphResult represents the relationship graph
type GraphResult struct {
	Nodes         []NodeInfo `json:"nodes"`
	Edges         []EdgeInfo `json:"edges"`
	TotalNodes    int        `json:"total_nodes"`
	TotalEdges    int        `json:"total_edges"`
	MaxDepth      int        `json:"max_depth"`
	ExecutionTime int64      `json:"execution_time_ms"`
}

// NodeInfo represents a node in the graph
type NodeInfo struct {
	ID         string `json:"id"`
	Content    string `json:"content"`
	Importance int    `json:"importance"`
	Distance   int    `json:"distance"`
	Domain     string `json:"domain,omitempty"`
	Tags       []string `json:"tags,omitempty"`
}

// EdgeInfo represents an edge in the graph
type EdgeInfo struct {
	SourceID string  `json:"source_id"`
	TargetID string  `json:"target_id"`
	Type     string  `json:"type"`
	Strength float64 `json:"strength"`
	Context  string  `json:"context,omitempty"`
}

// MapGraph maps the relationship graph starting from a memory
// VERIFIED: Matches local-memory map_graph behavior with BFS
// Performance target: 4ms execution time
func (s *Service) MapGraph(opts *MapGraphOptions) (*GraphResult, error) {
	if opts.RootID == "" {
		return nil, fmt.Errorf("root_id is required")
	}

	// Validate memory exists
	mem, err := s.db.GetMemory(opts.RootID)
	if err != nil {
		return nil, fmt.Errorf("failed to get memory: %w", err)
	}
	if mem == nil {
		return nil, fmt.Errorf("memory not found: %s", opts.RootID)
	}

	// Set default depth
	depth := opts.Depth
	if depth <= 0 {
		depth = 2
	}
	if depth > 5 {
		depth = 5 // Max depth
	}

	// Get graph from database
	graph, err := s.db.GetGraph(opts.RootID, depth)
	if err != nil {
		return nil, fmt.Errorf("failed to map graph: %w", err)
	}

	// Convert to result format
	result := &GraphResult{
		TotalNodes: len(graph.Nodes),
		TotalEdges: len(graph.Edges),
		MaxDepth:   depth,
	}

	// Filter and convert nodes
	for _, node := range graph.Nodes {
		nodeInfo := NodeInfo{
			ID:         node.ID,
			Content:    node.Content,
			Importance: node.Importance,
			Distance:   node.Distance,
		}
		result.Nodes = append(result.Nodes, nodeInfo)
	}

	// Filter and convert edges
	typeFilter := make(map[string]bool)
	for _, t := range opts.IncludeTypes {
		typeFilter[strings.ToLower(t)] = true
	}

	for _, edge := range graph.Edges {
		// Apply type filter
		if len(typeFilter) > 0 && !typeFilter[edge.Type] {
			continue
		}

		// Apply strength filter
		if edge.Strength < opts.MinStrength {
			continue
		}

		edgeInfo := EdgeInfo{
			SourceID: edge.SourceID,
			TargetID: edge.TargetID,
			Type:     edge.Type,
			Strength: edge.Strength,
		}
		result.Edges = append(result.Edges, edgeInfo)
	}

	return result, nil
}

// DiscoverOptions contains options for discovering relationships
type DiscoverOptions struct {
	Limit       int
	MinStrength float64
}

// DiscoveredRelationship represents a potential relationship found by AI
type DiscoveredRelationship struct {
	SourceID    string  `json:"source_id"`
	TargetID    string  `json:"target_id"`
	Type        string  `json:"type"`
	Strength    float64 `json:"strength"`
	Reasoning   string  `json:"reasoning"`
	Confidence  float64 `json:"confidence"`
}

// Discover uses AI to discover potential relationships between memories
// NOTE: Full implementation requires Ollama (Phase 4)
func (s *Service) Discover(opts *DiscoverOptions) ([]*DiscoveredRelationship, error) {
	// TODO: Implement AI-powered relationship discovery in Phase 4
	// 1. Get recent memories
	// 2. Generate embeddings
	// 3. Find similar pairs
	// 4. Use LLM to classify relationship type
	// 5. Return discovered relationships

	return []*DiscoveredRelationship{}, nil
}

// GetRelationshipTypes returns all valid relationship types
// VERIFIED: 7 relationship types from local-memory
func GetRelationshipTypes() []RelationshipTypeInfo {
	return []RelationshipTypeInfo{
		{Name: "references", Description: "Memory references another"},
		{Name: "contradicts", Description: "Memory contradicts another"},
		{Name: "expands", Description: "Memory expands on another"},
		{Name: "similar", Description: "Memory is similar to another"},
		{Name: "sequential", Description: "Memory follows another in sequence"},
		{Name: "causes", Description: "Memory causes another"},
		{Name: "enables", Description: "Memory enables another"},
	}
}

// RelationshipTypeInfo describes a relationship type
type RelationshipTypeInfo struct {
	Name        string `json:"name"`
	Description string `json:"description"`
}

// ValidateRelationshipType validates a relationship type
func ValidateRelationshipType(t string) error {
	if !database.IsValidRelationshipType(strings.ToLower(t)) {
		return fmt.Errorf("invalid relationship type: %s (valid: %s)",
			t, strings.Join(database.RelationshipTypes, ", "))
	}
	return nil
}

package mcp

import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	"github.com/MycelicMemory/mycelicmemory/internal/ai"
	"github.com/MycelicMemory/mycelicmemory/internal/benchmark"
	"github.com/MycelicMemory/mycelicmemory/internal/database"
	"github.com/MycelicMemory/mycelicmemory/internal/memory"
	"github.com/MycelicMemory/mycelicmemory/internal/relationships"
	"github.com/MycelicMemory/mycelicmemory/internal/search"
)

// Response types for tool handlers

type StoreMemoryResponse struct {
	Success   bool   `json:"success"`
	MemoryID  string `json:"memory_id"`
	Content   string `json:"content"`
	CreatedAt string `json:"created_at"`
	SessionID string `json:"session_id"`
}

type SearchResponse struct {
	Count          int               `json:"count"`
	Optimization   *OptimizationInfo `json:"optimization,omitempty"`
	Results        []SearchResultLM  `json:"results"`
	SearchMetadata *SearchMetadata   `json:"search_metadata,omitempty"`
	SizeMetadata   *SizeMetadata     `json:"size_metadata,omitempty"`
}

type OptimizationInfo struct {
	CompressionRatio  float64 `json:"compression_ratio"`
	IsWithinBudget    bool    `json:"is_within_budget"`
	OriginalRequest   string  `json:"original_request"`
	ResponseFormat    string  `json:"response_format"`
	TokenOptimization bool    `json:"token_optimization"`
	WasIntelligent    bool    `json:"was_intelligent"`
}

type SearchResultLM struct {
	Memory         *MemoryFull `json:"memory"`
	RelevanceScore float64     `json:"relevance_score"`
}

type MemoryFull struct {
	ID         string   `json:"id"`
	Content    string   `json:"content"`
	Importance int      `json:"importance"`
	Tags       []string `json:"tags"`
	SessionID  string   `json:"session_id"`
	Domain     string   `json:"domain,omitempty"`
	CreatedAt  string   `json:"created_at"`
	UpdatedAt  string   `json:"updated_at"`
}

type SearchMetadata struct {
	Query        string `json:"query"`
	SearchType   string `json:"search_type"`
	TotalResults int    `json:"total_results"`
}

type SizeMetadata struct {
	EstimatedTokens     int           `json:"estimated_tokens"`
	EstimatedChars      int           `json:"estimated_chars"`
	EstimatedBytes      int           `json:"estimated_bytes"`
	Format              string        `json:"format"`
	ResultCount         int           `json:"result_count"`
	ProcessingTimeMs    int           `json:"processing_time_ms"`
	CompressionRatio    float64       `json:"compression_ratio"`
	IsWithinTokenBudget bool          `json:"is_within_token_budget"`
	TokenBudget         int           `json:"token_budget"`
	Recommendations     []string      `json:"recommendations"`
}

// AnalysisQuestionResponse matches local-memory's question response
type AnalysisQuestionResponse struct {
	Answer     string        `json:"answer"`
	Confidence float64       `json:"confidence"`
	Reasoning  string        `json:"reasoning,omitempty"`
	Sources    []*MemoryFull `json:"sources"`
}

// AnalysisSummarizeResponse matches local-memory's summarize response
type AnalysisSummarizeResponse struct {
	KeyThemes   []string      `json:"key_themes"`
	MemoryCount int           `json:"memory_count"`
	SessionID   *string       `json:"session_id"`
	Sources     []*MemoryFull `json:"sources"`
	Summary     string        `json:"summary"`
	Timeframe   string        `json:"timeframe"`
}

type RelationshipsResponse struct {
	Success       bool                `json:"success"`
	Relationships []RelationshipInfo  `json:"relationships,omitempty"`
	Graph         *GraphResponse      `json:"graph,omitempty"`
	Created       *RelationshipInfo   `json:"created,omitempty"`
}

// DiscoverRelationshipsResponse matches local-memory's discover response format
type DiscoverRelationshipsResponse struct {
	ProcessingTimeMs int                          `json:"processing_time_ms"`
	Relationships    []DiscoveredRelationshipInfo `json:"relationships"`
	TotalFound       int                          `json:"total_found"`
}

// DiscoveredRelationshipInfo matches local-memory's discover relationship item format
type DiscoveredRelationshipInfo struct {
	Explanation  string                `json:"explanation"`
	Relationship *RelationshipDetail   `json:"relationship"`
	SourceMemory *MemoryFullWithEmbed  `json:"source_memory"`
	TargetMemory *MemoryFullWithEmbed  `json:"target_memory"`
}

// RelationshipDetail matches local-memory's relationship object format
type RelationshipDetail struct {
	ID               string  `json:"id"`
	AutoGenerated    bool    `json:"auto_generated"`
	Context          string  `json:"context"`
	CreatedAt        string  `json:"created_at"`
	RelationshipType string  `json:"relationship_type"`
	SourceMemoryID   string  `json:"source_memory_id"`
	Strength         float64 `json:"strength"`
	TargetMemoryID   string  `json:"target_memory_id"`
}

// MemoryFullWithEmbed includes empty embedding array like local-memory
type MemoryFullWithEmbed struct {
	ID         string   `json:"id"`
	Content    string   `json:"content"`
	Importance int      `json:"importance"`
	Tags       []string `json:"tags"`
	SessionID  string   `json:"session_id"`
	Domain     string   `json:"domain,omitempty"`
	CreatedAt  string   `json:"created_at"`
	UpdatedAt  string   `json:"updated_at"`
	Embedding  []byte   `json:"embedding"`
	Source     *string  `json:"source"`
	Slug       *string  `json:"slug"`
}

type RelationshipInfo struct {
	ID               string  `json:"id"`
	SourceID         string  `json:"source_id"`
	TargetID         string  `json:"target_id"`
	Type             string  `json:"type"`
	Strength         float64 `json:"strength"`
	RelatedContent   string  `json:"related_content,omitempty"`
}

// FindRelatedResultLM matches local-memory's find_related response item format
type FindRelatedResultLM struct {
	Memory          *MemoryFullWithEmbed `json:"memory"`
	QualityScore    float64              `json:"quality_score"`
	RelevanceScore  float64              `json:"relevance_score"`
	SimilarityScore *float64             `json:"similarity_score"`
}

type GraphResponse struct {
	Nodes      []NodeInfo `json:"nodes"`
	Edges      []EdgeInfo `json:"edges"`
	TotalNodes int        `json:"total_nodes"`
	TotalEdges int        `json:"total_edges"`
}

// MapGraphResponseLM matches local-memory's map_graph response format
type MapGraphResponseLM struct {
	CentralMemory *MemoryFullWithEmbed `json:"central_memory"`
	Depth         int                  `json:"depth"`
	Edges         []*RelationshipDetail `json:"edges"`
	Nodes         []MapGraphNodeLM     `json:"nodes"`
	TotalNodes    int                  `json:"total_nodes"`
}

// MapGraphNodeLM matches local-memory's map_graph node format
type MapGraphNodeLM struct {
	Distance      int                   `json:"distance"`
	Memory        *MemoryFullWithEmbed  `json:"memory"`
	Relationships []*RelationshipDetail `json:"relationships"`
}

type NodeInfo struct {
	ID         string `json:"id"`
	Content    string `json:"content"`
	Distance   int    `json:"distance"`
	Importance int    `json:"importance"`
}

type EdgeInfo struct {
	SourceID string  `json:"source_id"`
	TargetID string  `json:"target_id"`
	Type     string  `json:"type"`
	Strength float64 `json:"strength"`
}

type CategoriesResponse struct {
	Success    bool           `json:"success"`
	Categories []CategoryInfo `json:"categories,omitempty"`
	Created    *CategoryInfo  `json:"created,omitempty"`
}

type CategoryInfo struct {
	ID          string `json:"id"`
	Name        string `json:"name"`
	Description string `json:"description,omitempty"`
}

// CategoryFullLM matches local-memory's category response format
type CategoryFullLM struct {
	ID                  string  `json:"id"`
	Name                string  `json:"name"`
	Description         string  `json:"description"`
	ConfidenceThreshold float64 `json:"confidence_threshold"`
	AutoGenerated       bool    `json:"auto_generated"`
	CreatedAt           string  `json:"created_at"`
}

type DomainsResponse struct {
	Success bool         `json:"success"`
	Domains []DomainInfo `json:"domains,omitempty"`
	Created *DomainInfo  `json:"created,omitempty"`
	Stats   *DomainStats `json:"stats,omitempty"`
}

type DomainInfo struct {
	ID          string `json:"id"`
	Name        string `json:"name"`
	Description string `json:"description,omitempty"`
}

// DomainFullLM matches local-memory's domain response format
type DomainFullLM struct {
	ID          string `json:"id"`
	Name        string `json:"name"`
	Description string `json:"description"`
	CreatedAt   string `json:"created_at"`
	UpdatedAt   string `json:"updated_at"`
}

type DomainStats struct {
	MemoryCount       int     `json:"memory_count"`
	AverageImportance float64 `json:"average_importance"`
}

type SessionsResponse struct {
	Success  bool          `json:"success"`
	Sessions []SessionInfo `json:"sessions,omitempty"`
	Stats    *SessionStats `json:"stats,omitempty"`
}

type SessionInfo struct {
	SessionID    string `json:"session_id"`
	AgentType    string `json:"agent_type"`
	CreatedAt    string `json:"created_at"`
	LastAccessed string `json:"last_accessed"`
}

// SessionInfoLM matches local-memory's session response format
type SessionInfoLM struct {
	ID           string `json:"id"`
	MemoryCount  int    `json:"memory_count"`
	LastAccessed string `json:"last_accessed"`
}

type SessionStats struct {
	TotalSessions int `json:"total_sessions"`
	TotalMemories int `json:"total_memories"`
}

type StatsResponse struct {
	Success      bool   `json:"success"`
	StatsType    string `json:"stats_type"`
	MemoryCount  int    `json:"memory_count"`
	SessionCount int    `json:"session_count,omitempty"`
}

type MemoryResponse struct {
	Success bool        `json:"success"`
	Memory  *MemoryInfo `json:"memory,omitempty"`
	Message string      `json:"message,omitempty"`
}

type MemoryInfo struct {
	ID         string   `json:"id"`
	Content    string   `json:"content"`
	Importance int      `json:"importance"`
	Tags       []string `json:"tags"`
	Domain     string   `json:"domain,omitempty"`
	SessionID  string   `json:"session_id"`
	CreatedAt  string   `json:"created_at"`
	UpdatedAt  string   `json:"updated_at"`
}

// Handler implementations

func (s *Server) handleStoreMemory(ctx context.Context, argsJSON []byte) (interface{}, error) {
	var params StoreMemoryParams
	if err := json.Unmarshal(argsJSON, &params); err != nil {
		s.log.Error("failed to parse store_memory params", "error", err)
		return nil, fmt.Errorf("invalid parameters: %w", err)
	}

	if params.Content == "" {
		s.log.Warn("store_memory called with empty content")
		return nil, fmt.Errorf("content is required")
	}

	importance := params.Importance
	if importance == 0 {
		importance = 5
	}

	s.log.Debug("storing memory", "importance", importance, "tags", params.Tags, "domain", params.Domain)

	result, err := s.memSvc.Store(&memory.StoreOptions{
		Content:    params.Content,
		Importance: importance,
		Tags:       params.Tags,
		Domain:     params.Domain,
		Source:     params.Source,
	})
	if err != nil {
		s.log.Error("failed to store memory", "error", err)
		return nil, fmt.Errorf("failed to store memory: %w", err)
	}

	s.log.LogOperation("store_memory", "memory_id", result.Memory.ID, "content_length", len(params.Content))

	return &StoreMemoryResponse{
		Success:   true,
		MemoryID:  result.Memory.ID,
		Content:   result.Memory.Content,
		CreatedAt: result.Memory.CreatedAt.Format("2006-01-02T15:04:05Z"),
		SessionID: result.Memory.SessionID,
	}, nil
}

func (s *Server) handleSearch(ctx context.Context, argsJSON []byte) (interface{}, error) {
	var params SearchParams
	if err := json.Unmarshal(argsJSON, &params); err != nil {
		s.log.Error("failed to parse search params", "error", err)
		return nil, fmt.Errorf("invalid parameters: %w", err)
	}

	limit := params.Limit
	if limit == 0 {
		limit = 10
	}

	searchType := params.SearchType
	if searchType == "" {
		searchType = "semantic"
	}

	responseFormat := params.ResponseFormat
	if responseFormat == "" {
		responseFormat = "detailed"
	}

	s.log.Debug("searching memories", "query", params.Query, "type", searchType, "limit", limit)

	results, err := s.searchEng.Search(&search.SearchOptions{
		Query:  params.Query,
		Limit:  limit,
		Domain: params.Domain,
		Tags:   params.Tags,
	})
	if err != nil {
		s.log.Error("search failed", "error", err, "query", params.Query)
		return nil, fmt.Errorf("search failed: %w", err)
	}

	s.log.LogOperation("search", "query", params.Query, "results", len(results))

	// Build response matching local-memory format
	searchResults := make([]SearchResultLM, len(results))
	estimatedChars := 0

	for i, r := range results {
		searchResults[i] = SearchResultLM{
			Memory: &MemoryFull{
				ID:         r.Memory.ID,
				Content:    r.Memory.Content,
				Importance: r.Memory.Importance,
				Tags:       r.Memory.Tags,
				SessionID:  r.Memory.SessionID,
				Domain:     r.Memory.Domain,
				CreatedAt:  r.Memory.CreatedAt.Format("2006-01-02T15:04:05.999999Z"),
				UpdatedAt:  r.Memory.UpdatedAt.Format("2006-01-02T15:04:05.999999Z"),
			},
			RelevanceScore: r.Relevance,
		}
		estimatedChars += len(r.Memory.Content)
	}

	response := &SearchResponse{
		Count:   len(results),
		Results: searchResults,
		Optimization: &OptimizationInfo{
			CompressionRatio:  0.7,
			IsWithinBudget:    true,
			OriginalRequest:   responseFormat,
			ResponseFormat:    responseFormat,
			TokenOptimization: false,
			WasIntelligent:    false,
		},
		SearchMetadata: &SearchMetadata{
			Query:        params.Query,
			SearchType:   searchType,
			TotalResults: len(results),
		},
		SizeMetadata: &SizeMetadata{
			EstimatedTokens:     estimatedChars / 4, // rough estimate
			EstimatedChars:      estimatedChars,
			EstimatedBytes:      estimatedChars,
			Format:              responseFormat,
			ResultCount:         len(results),
			ProcessingTimeMs:    0,
			CompressionRatio:    0.7,
			IsWithinTokenBudget: true,
			TokenBudget:         1000,
			Recommendations:     []string{"Response size within budget"},
		},
	}

	return response, nil
}

func (s *Server) handleAnalysis(ctx context.Context, argsJSON []byte) (interface{}, error) {
	var params AnalysisParams
	if err := json.Unmarshal(argsJSON, &params); err != nil {
		s.log.Error("failed to parse analysis params", "error", err)
		return nil, fmt.Errorf("invalid parameters: %w", err)
	}

	analysisType := params.AnalysisType
	if analysisType == "" {
		analysisType = "question"
	}

	limit := params.Limit
	if limit == 0 {
		limit = 10
	}

	timeframe := params.Timeframe
	if timeframe == "" {
		timeframe = "all"
	}

	s.log.Debug("running analysis", "type", analysisType, "timeframe", timeframe, "limit", limit)

	// Check AI availability
	status := s.aiManager.GetStatus()
	if !status.OllamaAvailable {
		s.log.Warn("AI analysis requested but Ollama unavailable")
		return nil, fmt.Errorf("AI analysis requires Ollama to be running")
	}

	opts := &ai.AnalysisOptions{
		Type:      analysisType,
		Question:  params.Question,
		Query:     params.Query,
		Timeframe: timeframe,
		Limit:     limit,
	}

	result, err := s.aiManager.Analyze(ctx, opts)
	if err != nil {
		s.log.Error("analysis failed", "error", err, "type", analysisType)
		return nil, fmt.Errorf("analysis failed: %w", err)
	}

	s.log.LogOperation("analysis", "type", analysisType, "sources", len(result.SourceMemories))

	// Convert sources to MemoryFull objects (matching local-memory format)
	sources := make([]*MemoryFull, 0, len(result.SourceMemories))
	for _, m := range result.SourceMemories {
		sources = append(sources, &MemoryFull{
			ID:         m.ID,
			Content:    m.Content,
			Importance: m.Importance,
			Tags:       m.Tags,
			SessionID:  m.SessionID,
			Domain:     m.Domain,
			CreatedAt:  m.CreatedAt.Format("2006-01-02T15:04:05-07:00"),
			UpdatedAt:  m.UpdatedAt.Format("2006-01-02T15:04:05-07:00"),
		})
	}

	// Return appropriate response type based on analysis type
	switch analysisType {
	case "question":
		avgRelevance := 0.0
		if len(result.SourceMemories) > 0 {
			avgRelevance = 0.61 // approximate
		}
		sessions := 1
		if len(result.SourceMemories) > 5 {
			sessions = 2
		}
		return &AnalysisQuestionResponse{
			Answer:     result.Answer,
			Confidence: result.Confidence,
			Reasoning:  fmt.Sprintf("Based on %d relevant memories found through vector similarity search. Average relevance: %.2f. Cross-session context: %d different sessions included", len(result.SourceMemories), avgRelevance, sessions),
			Sources:    sources,
		}, nil

	case "summarize":
		return &AnalysisSummarizeResponse{
			KeyThemes:   result.KeyThemes,
			MemoryCount: result.MemoryCount,
			SessionID:   nil,
			Sources:     sources,
			Summary:     result.Summary,
			Timeframe:   timeframe,
		}, nil

	default:
		// For analyze and temporal_patterns, use summarize format
		return &AnalysisSummarizeResponse{
			KeyThemes:   result.KeyThemes,
			MemoryCount: result.MemoryCount,
			SessionID:   nil,
			Sources:     sources,
			Summary:     result.Summary,
			Timeframe:   timeframe,
		}, nil
	}
}

func (s *Server) handleRelationships(ctx context.Context, argsJSON []byte) (interface{}, error) {
	var params RelationshipsParams
	if err := json.Unmarshal(argsJSON, &params); err != nil {
		return nil, fmt.Errorf("invalid parameters: %w", err)
	}

	relType := params.RelationshipType
	if relType == "" {
		relType = "find_related"
	}

	switch relType {
	case "find_related":
		if params.MemoryID == "" {
			return nil, fmt.Errorf("memory_id is required for find_related")
		}
		return s.handleFindRelated(params)

	case "create":
		if params.SourceMemoryID == "" || params.TargetMemoryID == "" {
			return nil, fmt.Errorf("source_memory_id and target_memory_id are required for create")
		}
		return s.handleCreateRelationship(params)

	case "map_graph":
		if params.MemoryID == "" {
			return nil, fmt.Errorf("memory_id is required for map_graph")
		}
		return s.handleMapGraph(params)

	case "discover":
		return s.handleDiscoverRelationships(ctx, params)

	default:
		return nil, fmt.Errorf("unknown relationship_type: %s", relType)
	}
}

func (s *Server) handleFindRelated(params RelationshipsParams) (interface{}, error) {
	limit := params.Limit
	if limit == 0 {
		limit = 10
	}

	results, err := s.relSvc.FindRelated(&relationships.FindRelatedOptions{
		MemoryID: params.MemoryID,
		Limit:    limit,
	})
	if err != nil {
		return nil, fmt.Errorf("find related failed: %w", err)
	}

	// Return array format like local-memory
	response := make([]FindRelatedResultLM, len(results))
	for i, r := range results {
		// Calculate relevance score based on importance and strength
		relevanceScore := float64(r.Memory.Importance) * r.Strength
		var simScore *float64
		if r.Strength > 0 {
			simScore = &r.Strength
		}

		response[i] = FindRelatedResultLM{
			Memory:          convertToMemoryFullWithEmbed(r.Memory),
			QualityScore:    0,
			RelevanceScore:  relevanceScore,
			SimilarityScore: simScore,
		}
	}

	return response, nil
}

func (s *Server) handleCreateRelationship(params RelationshipsParams) (interface{}, error) {
	relTypeEnum := params.RelationshipTypeEnum
	if relTypeEnum == "" {
		relTypeEnum = "references"
	}

	strength := params.Strength
	if strength == 0 {
		strength = 0.5
	}

	rel, err := s.relSvc.Create(&relationships.CreateOptions{
		SourceMemoryID:   params.SourceMemoryID,
		TargetMemoryID:   params.TargetMemoryID,
		RelationshipType: relTypeEnum,
		Strength:         strength,
		Context:          params.Context,
	})
	if err != nil {
		return nil, fmt.Errorf("create relationship failed: %w", err)
	}

	// Return flat format like local-memory
	return &RelationshipDetail{
		ID:               rel.ID,
		AutoGenerated:    false,
		Context:          rel.Context,
		CreatedAt:        rel.CreatedAt.Format(time.RFC3339Nano),
		RelationshipType: rel.RelationshipType,
		SourceMemoryID:   rel.SourceMemoryID,
		Strength:         rel.Strength,
		TargetMemoryID:   rel.TargetMemoryID,
	}, nil
}

func (s *Server) handleMapGraph(params RelationshipsParams) (interface{}, error) {
	depth := params.Depth
	if depth == 0 {
		depth = 2
	}

	result, err := s.relSvc.MapGraph(&relationships.MapGraphOptions{
		RootID:      params.MemoryID,
		Depth:       depth,
		MinStrength: params.MinStrength,
	})
	if err != nil {
		return nil, fmt.Errorf("map graph failed: %w", err)
	}

	// Get central memory
	centralMem, err := s.db.GetMemory(params.MemoryID)
	if err != nil {
		return nil, fmt.Errorf("failed to get central memory: %w", err)
	}

	// Build nodes with full memory objects like local-memory
	nodes := make([]MapGraphNodeLM, len(result.Nodes))
	for i, n := range result.Nodes {
		mem, err := s.db.GetMemory(n.ID)
		if err != nil {
			continue
		}

		// Get relationships for this node
		rels, _ := s.db.GetRelationshipsForMemory(n.ID)
		relDetails := make([]*RelationshipDetail, len(rels))
		for j, r := range rels {
			relDetails[j] = &RelationshipDetail{
				ID:               r.ID,
				AutoGenerated:    r.AutoGenerated,
				Context:          r.Context,
				CreatedAt:        r.CreatedAt.Format(time.RFC3339Nano),
				RelationshipType: r.RelationshipType,
				SourceMemoryID:   r.SourceMemoryID,
				Strength:         r.Strength,
				TargetMemoryID:   r.TargetMemoryID,
			}
		}

		nodes[i] = MapGraphNodeLM{
			Distance:      n.Distance,
			Memory:        convertToMemoryFullWithEmbed(mem),
			Relationships: relDetails,
		}
	}

	// Build edges with full relationship details
	edges := make([]*RelationshipDetail, len(result.Edges))
	for i, e := range result.Edges {
		edges[i] = &RelationshipDetail{
			ID:               "",
			AutoGenerated:    false,
			Context:          "",
			CreatedAt:        time.Now().Format(time.RFC3339Nano),
			RelationshipType: e.Type,
			SourceMemoryID:   e.SourceID,
			Strength:         e.Strength,
			TargetMemoryID:   e.TargetID,
		}
	}

	return &MapGraphResponseLM{
		CentralMemory: convertToMemoryFullWithEmbed(centralMem),
		Depth:         depth,
		Edges:         edges,
		Nodes:         nodes,
		TotalNodes:    result.TotalNodes,
	}, nil
}

func (s *Server) handleDiscoverRelationships(ctx context.Context, params RelationshipsParams) (interface{}, error) {
	startTime := time.Now()

	limit := params.Limit
	if limit == 0 {
		limit = 10
	}

	suggestions, err := s.aiManager.DiscoverRelationships(ctx, limit)
	if err != nil {
		return nil, fmt.Errorf("discover relationships failed: %w", err)
	}

	// Build response with full memory objects like local-memory
	rels := make([]DiscoveredRelationshipInfo, 0, len(suggestions))
	now := time.Now().Format(time.RFC3339Nano)

	for _, sug := range suggestions {
		// Fetch full memory objects
		sourceMem, err := s.db.GetMemory(sug.SourceID)
		if err != nil {
			continue // Skip if memory not found
		}
		targetMem, err := s.db.GetMemory(sug.TargetID)
		if err != nil {
			continue // Skip if memory not found
		}

		// Create the discovered relationship info
		relInfo := DiscoveredRelationshipInfo{
			Explanation: sug.Reasoning,
			Relationship: &RelationshipDetail{
				ID:               "", // Empty for discovered, not yet persisted
				AutoGenerated:    true,
				Context:          sug.Reasoning,
				CreatedAt:        now,
				RelationshipType: sug.Type,
				SourceMemoryID:   sug.SourceID,
				Strength:         sug.Confidence,
				TargetMemoryID:   sug.TargetID,
			},
			SourceMemory: convertToMemoryFullWithEmbed(sourceMem),
			TargetMemory: convertToMemoryFullWithEmbed(targetMem),
		}
		rels = append(rels, relInfo)
	}

	processingTimeMs := int(time.Since(startTime).Milliseconds())

	return &DiscoverRelationshipsResponse{
		ProcessingTimeMs: processingTimeMs,
		Relationships:    rels,
		TotalFound:       len(rels),
	}, nil
}

// convertToMemoryFullWithEmbed converts a database.Memory to MemoryFullWithEmbed
func convertToMemoryFullWithEmbed(m *database.Memory) *MemoryFullWithEmbed {
	tags := m.Tags
	if tags == nil {
		tags = []string{}
	}
	return &MemoryFullWithEmbed{
		ID:         m.ID,
		Content:    m.Content,
		Importance: m.Importance,
		Tags:       tags,
		SessionID:  m.SessionID,
		Domain:     m.Domain,
		CreatedAt:  m.CreatedAt.Format(time.RFC3339Nano),
		UpdatedAt:  m.UpdatedAt.Format(time.RFC3339Nano),
		Embedding:  []byte{}, // Empty array like local-memory
		Source:     nil,
		Slug:       nil,
	}
}

func (s *Server) handleCategories(ctx context.Context, argsJSON []byte) (interface{}, error) {
	var params CategoriesParams
	if err := json.Unmarshal(argsJSON, &params); err != nil {
		return nil, fmt.Errorf("invalid parameters: %w", err)
	}

	catType := params.CategoriesType
	if catType == "" {
		catType = "list"
	}

	switch catType {
	case "list":
		categories, err := s.db.ListCategories()
		if err != nil {
			return nil, fmt.Errorf("list categories failed: %w", err)
		}

		// Return flat array like local-memory
		cats := make([]CategoryFullLM, len(categories))
		for i, c := range categories {
			cats[i] = CategoryFullLM{
				ID:                  c.ID,
				Name:                c.Name,
				Description:         c.Description,
				ConfidenceThreshold: c.ConfidenceThreshold,
				AutoGenerated:       c.AutoGenerated,
				CreatedAt:           c.CreatedAt.Format(time.RFC3339Nano),
			}
		}

		return cats, nil

	case "create":
		if params.Name == "" {
			return nil, fmt.Errorf("name is required for create")
		}

		category := &database.Category{
			Name:        params.Name,
			Description: params.Description,
		}

		if err := s.db.CreateCategory(category); err != nil {
			return nil, fmt.Errorf("create category failed: %w", err)
		}

		return &CategoriesResponse{
			Success: true,
			Created: &CategoryInfo{
				ID:          category.ID,
				Name:        category.Name,
				Description: category.Description,
			},
		}, nil

	case "categorize":
		// Placeholder - needs AI categorization implementation
		return &CategoriesResponse{
			Success: true,
		}, nil

	default:
		return nil, fmt.Errorf("unknown categories_type: %s", catType)
	}
}

func (s *Server) handleDomains(ctx context.Context, argsJSON []byte) (interface{}, error) {
	var params DomainsParams
	if err := json.Unmarshal(argsJSON, &params); err != nil {
		return nil, fmt.Errorf("invalid parameters: %w", err)
	}

	domType := params.DomainsType
	if domType == "" {
		domType = "list"
	}

	switch domType {
	case "list":
		domains, err := s.db.ListDomains()
		if err != nil {
			return nil, fmt.Errorf("list domains failed: %w", err)
		}

		// Return flat array like local-memory
		doms := make([]DomainFullLM, len(domains))
		for i, d := range domains {
			doms[i] = DomainFullLM{
				ID:          d.ID,
				Name:        d.Name,
				Description: d.Description,
				CreatedAt:   d.CreatedAt.Format(time.RFC3339),
				UpdatedAt:   d.UpdatedAt.Format(time.RFC3339),
			}
		}

		return doms, nil

	case "create":
		if params.Name == "" {
			return nil, fmt.Errorf("name is required for create")
		}

		domain := &database.Domain{
			Name:        params.Name,
			Description: params.Description,
		}

		if err := s.db.CreateDomain(domain); err != nil {
			return nil, fmt.Errorf("create domain failed: %w", err)
		}

		// Return flat object like local-memory
		return &DomainFullLM{
			ID:          domain.ID,
			Name:        domain.Name,
			Description: domain.Description,
			CreatedAt:   domain.CreatedAt.Format(time.RFC3339),
			UpdatedAt:   domain.UpdatedAt.Format(time.RFC3339),
		}, nil

	case "stats":
		if params.Domain == "" {
			return nil, fmt.Errorf("domain is required for stats")
		}

		stats, err := s.db.GetDomainStats(params.Domain)
		if err != nil {
			return nil, fmt.Errorf("get domain stats failed: %w", err)
		}

		return &DomainsResponse{
			Success: true,
			Stats: &DomainStats{
				MemoryCount:       stats.MemoryCount,
				AverageImportance: stats.AverageImportance,
			},
		}, nil

	default:
		return nil, fmt.Errorf("unknown domains_type: %s", domType)
	}
}

func (s *Server) handleSessions(ctx context.Context, argsJSON []byte) (interface{}, error) {
	var params SessionsParams
	if err := json.Unmarshal(argsJSON, &params); err != nil {
		return nil, fmt.Errorf("invalid parameters: %w", err)
	}

	sessType := params.SessionsType
	if sessType == "" {
		sessType = "list"
	}

	switch sessType {
	case "list":
		sessions, err := s.db.ListSessions()
		if err != nil {
			return nil, fmt.Errorf("list sessions failed: %w", err)
		}

		// Return flat array like local-memory
		sessList := make([]SessionInfoLM, len(sessions))
		for i, sess := range sessions {
			// Get memory count for this session
			memCount := 0
			if count, err := s.db.GetMemoryCountBySession(sess.SessionID); err == nil {
				memCount = count
			}
			sessList[i] = SessionInfoLM{
				ID:           sess.SessionID,
				MemoryCount:  memCount,
				LastAccessed: sess.LastAccessed.Format(time.RFC3339Nano),
			}
		}

		return sessList, nil

	case "stats":
		stats, err := s.db.GetStats()
		if err != nil {
			return nil, fmt.Errorf("get stats failed: %w", err)
		}

		return &SessionsResponse{
			Success: true,
			Stats: &SessionStats{
				TotalSessions: stats.SessionCount,
				TotalMemories: stats.MemoryCount,
			},
		}, nil

	default:
		return nil, fmt.Errorf("unknown sessions_type: %s", sessType)
	}
}

func (s *Server) handleStats(ctx context.Context, argsJSON []byte) (interface{}, error) {
	var params StatsParams
	if err := json.Unmarshal(argsJSON, &params); err != nil {
		return nil, fmt.Errorf("invalid parameters: %w", err)
	}

	statsType := params.StatsType
	if statsType == "" {
		statsType = "session"
	}

	stats, err := s.db.GetStats()
	if err != nil {
		return nil, fmt.Errorf("get stats failed: %w", err)
	}

	return &StatsResponse{
		Success:      true,
		StatsType:    statsType,
		MemoryCount:  stats.MemoryCount,
		SessionCount: stats.SessionCount,
	}, nil
}

func (s *Server) handleGetMemory(ctx context.Context, argsJSON []byte) (interface{}, error) {
	var params GetMemoryParams
	if err := json.Unmarshal(argsJSON, &params); err != nil {
		return nil, fmt.Errorf("invalid parameters: %w", err)
	}

	if params.ID == "" {
		return nil, fmt.Errorf("id is required")
	}

	mem, err := s.memSvc.Get(&memory.GetOptions{ID: params.ID})
	if err != nil {
		return nil, fmt.Errorf("get memory failed: %w", err)
	}

	if mem == nil {
		return &MemoryResponse{
			Success: false,
			Message: "Memory not found",
		}, nil
	}

	return &MemoryResponse{
		Success: true,
		Memory: &MemoryInfo{
			ID:         mem.ID,
			Content:    mem.Content,
			Importance: mem.Importance,
			Tags:       mem.Tags,
			Domain:     mem.Domain,
			SessionID:  mem.SessionID,
			CreatedAt:  mem.CreatedAt.Format("2006-01-02T15:04:05Z"),
			UpdatedAt:  mem.UpdatedAt.Format("2006-01-02T15:04:05Z"),
		},
	}, nil
}

func (s *Server) handleUpdateMemory(ctx context.Context, argsJSON []byte) (interface{}, error) {
	var params UpdateMemoryParams
	if err := json.Unmarshal(argsJSON, &params); err != nil {
		return nil, fmt.Errorf("invalid parameters: %w", err)
	}

	if params.ID == "" {
		return nil, fmt.Errorf("id is required")
	}

	opts := &memory.UpdateOptions{ID: params.ID}

	if params.Content != "" {
		opts.Content = &params.Content
	}
	if params.Importance > 0 {
		opts.Importance = &params.Importance
	}
	if len(params.Tags) > 0 {
		opts.Tags = params.Tags
	}

	mem, err := s.memSvc.Update(opts)
	if err != nil {
		return nil, fmt.Errorf("update memory failed: %w", err)
	}

	return &MemoryResponse{
		Success: true,
		Memory: &MemoryInfo{
			ID:         mem.ID,
			Content:    mem.Content,
			Importance: mem.Importance,
			Tags:       mem.Tags,
			Domain:     mem.Domain,
			SessionID:  mem.SessionID,
			CreatedAt:  mem.CreatedAt.Format("2006-01-02T15:04:05Z"),
			UpdatedAt:  mem.UpdatedAt.Format("2006-01-02T15:04:05Z"),
		},
	}, nil
}

func (s *Server) handleDeleteMemory(ctx context.Context, argsJSON []byte) (interface{}, error) {
	var params DeleteMemoryParams
	if err := json.Unmarshal(argsJSON, &params); err != nil {
		return nil, fmt.Errorf("invalid parameters: %w", err)
	}

	if params.ID == "" {
		return nil, fmt.Errorf("id is required")
	}

	if err := s.memSvc.Delete(params.ID); err != nil {
		return nil, fmt.Errorf("delete memory failed: %w", err)
	}

	return &MemoryResponse{
		Success: true,
		Message: fmt.Sprintf("Memory %s deleted successfully", params.ID),
	}, nil
}

// =============================================================================
// BENCHMARK HANDLERS
// =============================================================================

// BenchmarkRunParams holds parameters for benchmark_run tool
type BenchmarkRunParams struct {
	MaxQuestions      int      `json:"max_questions"`
	Categories        []string `json:"categories"`
	ChangeDescription string   `json:"change_description"`
	Async             bool     `json:"async"`
	BenchmarkType     string   `json:"benchmark_type"`
	RandomSample      bool     `json:"random_sample"`
	Seed              *int     `json:"seed,omitempty"`
}

// BenchmarkStatusParams holds parameters for benchmark_status tool
type BenchmarkStatusParams struct {
	RunID          string `json:"run_id"`
	IncludeDetails bool   `json:"include_details"`
}

// BenchmarkResultsParams holds parameters for benchmark_results tool
type BenchmarkResultsParams struct {
	Limit     int    `json:"limit"`
	GitCommit string `json:"git_commit"`
	Since     string `json:"since"`
	BestOnly  bool   `json:"best_only"`
}

// BenchmarkCompareParams holds parameters for benchmark_compare tool
type BenchmarkCompareParams struct {
	RunIDA      string `json:"run_id_a"`
	RunIDB      string `json:"run_id_b"`
	DetailLevel string `json:"detail_level"`
}

func (s *Server) handleBenchmarkRun(ctx context.Context, argsJSON []byte) (interface{}, error) {
	var params BenchmarkRunParams
	if err := json.Unmarshal(argsJSON, &params); err != nil {
		return nil, fmt.Errorf("invalid parameters: %w", err)
	}

	// Check if bridge is available
	if err := s.benchmarkSvc.CheckBridge(); err != nil {
		return map[string]interface{}{
			"success": false,
			"error":   "Python benchmark bridge is not running. Start it with 'make server' in benchmark/locomo/",
		}, nil
	}

	// Default max questions
	if params.MaxQuestions == 0 {
		params.MaxQuestions = 20 // Quick test by default
	}

	// Default benchmark type
	benchmarkType := params.BenchmarkType
	if benchmarkType == "" {
		benchmarkType = "locomo10"
	}

	// Build config
	config := &benchmark.RunConfig{
		BenchmarkType: benchmarkType,
		MaxQuestions:  params.MaxQuestions,
		QuestionTypes: params.Categories,
		ChangeDesc:    params.ChangeDescription,
		Async:         params.Async,
		RandomSample:  params.RandomSample,
		Seed:          params.Seed,
	}

	// Run benchmark
	results, err := s.benchmarkSvc.Run(ctx, config)
	if err != nil {
		return map[string]interface{}{
			"success": false,
			"error":   err.Error(),
		}, nil
	}

	// Format response
	response := map[string]interface{}{
		"success": true,
		"run_id":  results.RunID,
		"status":  string(results.Status),
		"git": map[string]interface{}{
			"commit": results.Git.ShortHash,
			"branch": results.Git.Branch,
			"dirty":  results.Git.Dirty,
		},
		"overall": map[string]interface{}{
			"llm_judge_accuracy": results.Overall.LLMJudgeAccuracy,
			"f1_score":           results.Overall.F1Score,
			"bleu1_score":        results.Overall.BLEU1Score,
			"total_questions":    results.Overall.TotalQuestions,
		},
		"by_category": results.ByCategory,
		"duration_seconds": results.DurationSecs,
	}

	return response, nil
}

func (s *Server) handleBenchmarkStatus(ctx context.Context, argsJSON []byte) (interface{}, error) {
	var params BenchmarkStatusParams
	if err := json.Unmarshal(argsJSON, &params); err != nil {
		return nil, fmt.Errorf("invalid parameters: %w", err)
	}

	// Check for active run
	if s.benchmarkSvc.IsRunning() {
		progress, err := s.benchmarkSvc.GetProgress(ctx)
		if err != nil {
			return map[string]interface{}{
				"running":   true,
				"run_id":    s.benchmarkSvc.GetActiveRunID(),
				"error":     err.Error(),
			}, nil
		}
		return map[string]interface{}{
			"running":          true,
			"run_id":           progress.RunID,
			"status":           string(progress.Status),
			"completed":        progress.CompletedCount,
			"total":            progress.TotalQuestions,
			"percent_complete": progress.PercentComplete,
			"elapsed_seconds":  progress.ElapsedSecs,
		}, nil
	}

	// Check specific run or best run
	if params.RunID != "" {
		run, err := s.benchmarkSvc.GetRun(params.RunID)
		if err != nil {
			return nil, fmt.Errorf("failed to get run: %w", err)
		}
		if run == nil {
			return map[string]interface{}{
				"error": "Run not found",
			}, nil
		}
		return formatRunSummary(run), nil
	}

	// Return recent runs
	runs, err := s.benchmarkSvc.ListRuns(&database.BenchmarkRunFilters{Limit: 5})
	if err != nil {
		return nil, fmt.Errorf("failed to list runs: %w", err)
	}

	summaries := make([]map[string]interface{}, len(runs))
	for i, run := range runs {
		summaries[i] = formatRunSummary(run)
	}

	return map[string]interface{}{
		"running":     false,
		"recent_runs": summaries,
	}, nil
}

func (s *Server) handleBenchmarkResults(ctx context.Context, argsJSON []byte) (interface{}, error) {
	var params BenchmarkResultsParams
	if err := json.Unmarshal(argsJSON, &params); err != nil {
		return nil, fmt.Errorf("invalid parameters: %w", err)
	}

	if params.Limit == 0 {
		params.Limit = 10
	}

	if params.BestOnly {
		best, err := s.benchmarkSvc.GetBestRun("locomo")
		if err != nil {
			return nil, fmt.Errorf("failed to get best run: %w", err)
		}
		if best == nil {
			return map[string]interface{}{
				"message": "No benchmark runs found",
			}, nil
		}
		return map[string]interface{}{
			"best_run": formatRunSummary(best),
		}, nil
	}

	filters := &database.BenchmarkRunFilters{
		Limit:     params.Limit,
		GitCommit: params.GitCommit,
	}

	if params.Since != "" {
		t, err := time.Parse("2006-01-02", params.Since)
		if err == nil {
			filters.Since = &t
		}
	}

	runs, err := s.benchmarkSvc.ListRuns(filters)
	if err != nil {
		return nil, fmt.Errorf("failed to list runs: %w", err)
	}

	results := make([]map[string]interface{}, len(runs))
	for i, run := range runs {
		results[i] = formatRunSummary(run)
	}

	return map[string]interface{}{
		"count":   len(results),
		"results": results,
	}, nil
}

func (s *Server) handleBenchmarkCompare(ctx context.Context, argsJSON []byte) (interface{}, error) {
	var params BenchmarkCompareParams
	if err := json.Unmarshal(argsJSON, &params); err != nil {
		return nil, fmt.Errorf("invalid parameters: %w", err)
	}

	if params.RunIDA == "" || params.RunIDB == "" {
		return nil, fmt.Errorf("both run_id_a and run_id_b are required")
	}

	comparison, err := s.benchmarkSvc.Compare(params.RunIDA, params.RunIDB)
	if err != nil {
		return nil, fmt.Errorf("comparison failed: %w", err)
	}

	response := map[string]interface{}{
		"run_a": params.RunIDA,
		"run_b": params.RunIDB,
		"overall": map[string]interface{}{
			"before":         comparison.OverallDiff.Before,
			"after":          comparison.OverallDiff.After,
			"diff":           comparison.OverallDiff.Diff,
			"percent_change": comparison.OverallDiff.PercentChange,
			"improved":       comparison.OverallDiff.Improved,
		},
		"improvements": comparison.Improvements,
		"regressions":  comparison.Regressions,
	}

	if params.DetailLevel == "categories" || params.DetailLevel == "questions" {
		categoryDiffs := make(map[string]interface{})
		for cat, diff := range comparison.CategoryDiffs {
			categoryDiffs[cat] = map[string]interface{}{
				"before":   diff.Before,
				"after":    diff.After,
				"diff":     diff.Diff,
				"improved": diff.Improved,
			}
		}
		response["category_diffs"] = categoryDiffs
	}

	if params.DetailLevel == "questions" {
		changedQuestions := make([]map[string]interface{}, len(comparison.ChangedQuestions))
		for i, q := range comparison.ChangedQuestions {
			changedQuestions[i] = map[string]interface{}{
				"question_id": q.QuestionID,
				"category":    q.Category,
				"was_correct": q.WasCorrect,
				"now_correct": q.NowCorrect,
				"improved":    q.Improved,
				"regressed":   q.Regressed,
			}
		}
		response["changed_questions"] = changedQuestions
	}

	return response, nil
}

func formatRunSummary(run *database.BenchmarkRun) map[string]interface{} {
	summary := map[string]interface{}{
		"run_id":     run.ID,
		"status":     run.Status,
		"started_at": run.StartedAt.Format(time.RFC3339),
		"git": map[string]interface{}{
			"commit": run.GitCommitHash[:7],
			"branch": run.GitBranch,
			"dirty":  run.GitDirty,
		},
	}

	if run.CompletedAt != nil {
		summary["completed_at"] = run.CompletedAt.Format(time.RFC3339)
	}
	if run.OverallScore != nil {
		summary["accuracy"] = *run.OverallScore
	}
	if run.TotalQuestions != nil {
		summary["total_questions"] = *run.TotalQuestions
	}
	if run.TotalCorrect != nil {
		summary["correct"] = *run.TotalCorrect
	}
	if run.DurationSeconds != nil {
		summary["duration_seconds"] = *run.DurationSeconds
	}
	if run.IsBestRun {
		summary["is_best"] = true
	}
	if run.ChangeDescription != "" {
		summary["change_description"] = run.ChangeDescription
	}

	return summary
}

// BenchmarkImproveParams holds parameters for benchmark_improve tool
type BenchmarkImproveParams struct {
	Action         string  `json:"action"`
	MaxIterations  int     `json:"max_iterations"`
	MinImprovement float64 `json:"min_improvement"`
}

func (s *Server) handleBenchmarkImprove(ctx context.Context, argsJSON []byte) (interface{}, error) {
	var params BenchmarkImproveParams
	if err := json.Unmarshal(argsJSON, &params); err != nil {
		return nil, fmt.Errorf("invalid parameters: %w", err)
	}

	if params.Action == "" {
		params.Action = "status"
	}

	switch params.Action {
	case "start":
		// Check bridge first
		if err := s.benchmarkSvc.CheckBridge(); err != nil {
			return map[string]interface{}{
				"success": false,
				"error":   "Python benchmark bridge is not running. Start it with 'make server' in benchmark/locomo/",
			}, nil
		}

		if params.MaxIterations == 0 {
			params.MaxIterations = 10
		}
		if params.MinImprovement == 0 {
			params.MinImprovement = 0.01
		}

		config := &benchmark.LoopConfig{
			MaxIterations:           params.MaxIterations,
			MinImprovementThreshold: params.MinImprovement,
			ConvergenceThreshold:    0.005,
			TimeoutMinutes:          120,
		}

		state, err := s.benchmarkSvc.StartLoop(ctx, config)
		if err != nil {
			return map[string]interface{}{
				"success": false,
				"error":   err.Error(),
			}, nil
		}

		return map[string]interface{}{
			"success":        true,
			"message":        "Autonomous improvement loop started",
			"loop_id":        state.ID,
			"max_iterations": params.MaxIterations,
		}, nil

	case "stop":
		if !s.benchmarkSvc.IsLoopRunning() {
			return map[string]interface{}{
				"success": false,
				"error":   "No improvement loop is currently running",
			}, nil
		}

		if err := s.benchmarkSvc.StopLoop(); err != nil {
			return map[string]interface{}{
				"success": false,
				"error":   err.Error(),
			}, nil
		}

		return map[string]interface{}{
			"success": true,
			"message": "Loop stop requested",
		}, nil

	case "status":
		state := s.benchmarkSvc.GetLoopState()
		if state == nil {
			return map[string]interface{}{
				"running": false,
				"message": "No improvement loop is active",
			}, nil
		}

		return map[string]interface{}{
			"running":           state.Status == benchmark.LoopRunning,
			"loop_id":           state.ID,
			"status":            string(state.Status),
			"current_iteration": state.CurrentIteration,
			"max_iterations":    state.MaxIterations,
			"baseline_score":    state.BaselineScore,
			"best_score":        state.BestScore,
			"current_score":     state.CurrentScore,
			"best_run_id":       state.BestRunID,
			"elapsed_minutes":   state.ElapsedMinutes,
			"stop_reason":       state.StopReason,
		}, nil

	default:
		return nil, fmt.Errorf("unknown action: %s (valid: start, stop, status)", params.Action)
	}
}

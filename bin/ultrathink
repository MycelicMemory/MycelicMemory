#!/usr/bin/env node

const { spawn, execSync } = require('child_process');
const path = require('path');
const os = require('os');
const fs = require('fs');
const https = require('https');
const http = require('http');
const { URL } = require('url');

const VERSION = '1.2.0';
const GITHUB_OWNER = 'MycelicMemory';
const GITHUB_REPO = 'ultrathink';

function getBinaryName() {
  const platform = os.platform();
  const arch = os.arch();

  switch (platform) {
    case 'darwin':
      return arch === 'arm64' ? 'ultrathink-macos-arm64' : 'ultrathink-macos-x64';
    case 'linux':
      return arch === 'arm64' ? 'ultrathink-linux-arm64' : 'ultrathink-linux-x64';
    case 'win32':
      return arch === 'arm64' ? 'ultrathink-windows-arm64.exe' : 'ultrathink-windows-x64.exe';
    default:
      console.error(`Unsupported platform: ${platform}-${arch}`);
      process.exit(1);
  }
}

function downloadFile(url, dest, maxRedirects = 5) {
  return new Promise((resolve, reject) => {
    if (maxRedirects <= 0) {
      reject(new Error('Too many redirects'));
      return;
    }

    const parsedUrl = new URL(url);
    const protocol = parsedUrl.protocol === 'https:' ? https : http;

    const request = protocol.get(url, {
      headers: { 'User-Agent': `ultrathink/${VERSION}` }
    }, (response) => {
      if (response.statusCode >= 300 && response.statusCode < 400 && response.headers.location) {
        const redirectUrl = new URL(response.headers.location, url).toString();
        downloadFile(redirectUrl, dest, maxRedirects - 1).then(resolve).catch(reject);
        return;
      }

      if (response.statusCode !== 200) {
        reject(new Error(`HTTP ${response.statusCode}`));
        return;
      }

      const file = fs.createWriteStream(dest);
      response.pipe(file);
      file.on('finish', () => { file.close(); resolve(); });
      file.on('error', (err) => { fs.unlink(dest, () => {}); reject(err); });
    });

    request.on('error', reject);
    request.setTimeout(120000, () => { request.destroy(); reject(new Error('Timeout')); });
  });
}

async function ensureBinary(binDir, binaryName, binaryPath) {
  if (fs.existsSync(binaryPath)) {
    return true;
  }

  console.log(`Downloading ultrathink binary for ${os.platform()}-${os.arch()}...`);

  const urls = [
    `https://github.com/${GITHUB_OWNER}/${GITHUB_REPO}/releases/download/v${VERSION}/${binaryName}`,
    `https://github.com/${GITHUB_OWNER}/${GITHUB_REPO}/releases/latest/download/${binaryName}`
  ];

  for (const url of urls) {
    try {
      await downloadFile(url, binaryPath);
      fs.chmodSync(binaryPath, 0o755);
      console.log('Download complete!');
      return true;
    } catch (err) {
      if (fs.existsSync(binaryPath)) fs.unlinkSync(binaryPath);
    }
  }

  console.error('Failed to download binary.');
  console.error(`Please download manually from: https://github.com/${GITHUB_OWNER}/${GITHUB_REPO}/releases`);
  console.error(`Or build from source: https://github.com/${GITHUB_OWNER}/${GITHUB_REPO}#build-from-source`);
  return false;
}

async function main() {
  const binDir = __dirname;
  const binaryName = getBinaryName();
  const binaryPath = path.join(binDir, binaryName);

  if (!await ensureBinary(binDir, binaryName, binaryPath)) {
    process.exit(1);
  }

  const child = spawn(binaryPath, process.argv.slice(2), {
    stdio: 'inherit',
    env: process.env
  });

  child.on('close', (code) => process.exit(code));
  child.on('error', (err) => {
    console.error(`Failed to start ultrathink: ${err.message}`);
    process.exit(1);
  });
}

main();
